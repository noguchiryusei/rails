/**
* vue v3.4.23
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function makeMap(e,t){const n=new Set(e.split(","));return t?e=>n.has(e.toLowerCase()):e=>n.has(e)}const e=Object.freeze({});const t=Object.freeze([]);const NOOP=()=>{};const NO=()=>false;const isOn=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97);const isModelListener=e=>e.startsWith("onUpdate:");const n=Object.assign;const remove=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)};const o=Object.prototype.hasOwnProperty;const hasOwn=(e,t)=>o.call(e,t);const r=Array.isArray;const isMap=e=>toTypeString(e)==="[object Map]";const isSet=e=>toTypeString(e)==="[object Set]";const isDate=e=>toTypeString(e)==="[object Date]";const isRegExp=e=>toTypeString(e)==="[object RegExp]";const isFunction=e=>typeof e==="function";const isString=e=>typeof e==="string";const isSymbol=e=>typeof e==="symbol";const isObject=e=>e!==null&&typeof e==="object";const isPromise=e=>(isObject(e)||isFunction(e))&&isFunction(e.then)&&isFunction(e.catch);const s=Object.prototype.toString;const toTypeString=e=>s.call(e);const toRawType=e=>toTypeString(e).slice(8,-1);const isPlainObject=e=>toTypeString(e)==="[object Object]";const isIntegerKey=e=>isString(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e;const i=makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");const a=makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");const cacheStringFunction=e=>{const t=Object.create(null);return n=>{const o=t[n];return o||(t[n]=e(n))}};const c=/-(\w)/g;const l=cacheStringFunction((e=>e.replace(c,((e,t)=>t?t.toUpperCase():""))));const u=/\B([A-Z])/g;const p=cacheStringFunction((e=>e.replace(u,"-$1").toLowerCase()));const d=cacheStringFunction((e=>e.charAt(0).toUpperCase()+e.slice(1)));const f=cacheStringFunction((e=>{const t=e?`on${d(e)}`:"";return t}));const hasChanged=(e,t)=>!Object.is(e,t);const invokeArrayFns=(e,t)=>{for(let n=0;n<e.length;n++)e[n](t)};const def=(e,t,n)=>{Object.defineProperty(e,t,{configurable:true,enumerable:false,value:n})};const looseToNumber=e=>{const t=parseFloat(e);return isNaN(t)?e:t};const toNumber=e=>{const t=isString(e)?Number(e):NaN;return isNaN(t)?e:t};let m;const getGlobalThis=()=>m||(m=typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:typeof window!=="undefined"?window:typeof global!=="undefined"?global:{});const g={1:"TEXT",2:"CLASS",4:"STYLE",8:"PROPS",16:"FULL_PROPS",32:"NEED_HYDRATION",64:"STABLE_FRAGMENT",128:"KEYED_FRAGMENT",256:"UNKEYED_FRAGMENT",512:"NEED_PATCH",1024:"DYNAMIC_SLOTS",2048:"DEV_ROOT_FRAGMENT",[-1]:"HOISTED",[-2]:"BAIL"};const y={1:"STABLE",2:"DYNAMIC",3:"FORWARDED"};const v="Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";const b=makeMap(v);const C=2;function generateCodeFrame(e,t=0,n=e.length){let o=e.split(/(\r?\n)/);const r=o.filter(((e,t)=>t%2===1));o=o.filter(((e,t)=>t%2===0));let s=0;const i=[];for(let e=0;e<o.length;e++){s+=o[e].length+(r[e]&&r[e].length||0);if(s>=t){for(let a=e-C;a<=e+C||n>s;a++){if(a<0||a>=o.length)continue;const c=a+1;i.push(`${c}${" ".repeat(Math.max(3-String(c).length,0))}|  ${o[a]}`);const l=o[a].length;const u=r[a]&&r[a].length||0;if(a===e){const e=t-(s-(l+u));const o=Math.max(1,n>s?l-e:n-t);i.push("   |  "+" ".repeat(e)+"^".repeat(o))}else if(a>e){if(n>s){const e=Math.max(Math.min(n-s,l),1);i.push("   |  "+"^".repeat(e))}s+=l+u}}break}}return i.join("\n")}function normalizeStyle(e){if(r(e)){const t={};for(let n=0;n<e.length;n++){const o=e[n];const r=isString(o)?parseStringStyle(o):normalizeStyle(o);if(r)for(const e in r)t[e]=r[e]}return t}if(isString(e)||isObject(e))return e}const S=/;(?![^(]*\))/g;const x=/:([^]+)/;const w=/\/\*[^]*?\*\//g;function parseStringStyle(e){const t={};e.replace(w,"").split(S).forEach((e=>{if(e){const n=e.split(x);n.length>1&&(t[n[0].trim()]=n[1].trim())}}));return t}function stringifyStyle(e){let t="";if(!e||isString(e))return t;for(const n in e){const o=e[n];const r=n.startsWith("--")?n:p(n);(isString(o)||typeof o==="number")&&(t+=`${r}:${o};`)}return t}function normalizeClass(e){let t="";if(isString(e))t=e;else if(r(e))for(let n=0;n<e.length;n++){const o=normalizeClass(e[n]);o&&(t+=o+" ")}else if(isObject(e))for(const n in e)e[n]&&(t+=n+" ");return t.trim()}function normalizeProps(e){if(!e)return null;let{class:t,style:n}=e;t&&!isString(t)&&(e.class=normalizeClass(t));n&&(e.style=normalizeStyle(n));return e}const E="html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";const k="svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";const _="annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";const T="area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";const N=makeMap(E);const R=makeMap(k);const A=makeMap(_);const $=makeMap(T);const O="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";const I=makeMap(O);const P=makeMap(O+",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");function includeBooleanAttr(e){return!!e||e===""}const V=makeMap("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap");const M=makeMap("xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan");function isRenderableAttrValue(e){if(e==null)return false;const t=typeof e;return t==="string"||t==="number"||t==="boolean"}function looseCompareArrays(e,t){if(e.length!==t.length)return false;let n=true;for(let o=0;n&&o<e.length;o++)n=looseEqual(e[o],t[o]);return n}function looseEqual(e,t){if(e===t)return true;let n=isDate(e);let o=isDate(t);if(n||o)return!(!n||!o)&&e.getTime()===t.getTime();n=isSymbol(e);o=isSymbol(t);if(n||o)return e===t;n=r(e);o=r(t);if(n||o)return!(!n||!o)&&looseCompareArrays(e,t);n=isObject(e);o=isObject(t);if(n||o){if(!n||!o)return false;const r=Object.keys(e).length;const s=Object.keys(t).length;if(r!==s)return false;for(const n in e){const o=e.hasOwnProperty(n);const r=t.hasOwnProperty(n);if(o&&!r||!o&&r||!looseEqual(e[n],t[n]))return false}}return String(e)===String(t)}function looseIndexOf(e,t){return e.findIndex((e=>looseEqual(e,t)))}const toDisplayString=e=>isString(e)?e:e==null?"":r(e)||isObject(e)&&(e.toString===s||!isFunction(e.toString))?JSON.stringify(e,replacer,2):String(e);const replacer=(e,t)=>t&&t.__v_isRef?replacer(e,t.value):isMap(t)?{[`Map(${t.size})`]:[...t.entries()].reduce(((e,[t,n],o)=>{e[stringifySymbol(t,o)+" =>"]=n;return e}),{})}:isSet(t)?{[`Set(${t.size})`]:[...t.values()].map((e=>stringifySymbol(e)))}:isSymbol(t)?stringifySymbol(t):!isObject(t)||r(t)||isPlainObject(t)?t:String(t);const stringifySymbol=(e,t="")=>{var n;return isSymbol(e)?`Symbol(${(n=e.description)!=null?n:t})`:e};function warn$2(e,...t){console.warn(`[Vue warn] ${e}`,...t)}let F;class EffectScope{constructor(e=false){this.detached=e;this._active=true;this.effects=[];this.cleanups=[];this.parent=F;!e&&F&&(this.index=(F.scopes||(F.scopes=[])).push(this)-1)}get active(){return this._active}run(e){if(this._active){const t=F;try{F=this;return e()}finally{F=t}}else warn$2("cannot run an inactive effect scope.")}on(){F=this}off(){F=this.parent}stop(e){if(this._active){let t,n;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].stop();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(true);if(!this.detached&&this.parent&&!e){const e=this.parent.scopes.pop();if(e&&e!==this){this.parent.scopes[this.index]=e;e.index=this.index}}this.parent=void 0;this._active=false}}}function effectScope(e){return new EffectScope(e)}function recordEffectScope(e,t=F){t&&t.active&&t.effects.push(e)}function getCurrentScope(){return F}function onScopeDispose(e){F?F.cleanups.push(e):warn$2("onScopeDispose() is called when there is no active effect scope to be associated with.")}let D;class ReactiveEffect{constructor(e,t,n,o){this.fn=e;this.trigger=t;this.scheduler=n;this.active=true;this.deps=[];this._dirtyLevel=4;this._trackId=0;this._runnings=0;this._shouldSchedule=false;this._depsLength=0;recordEffectScope(this,o)}get dirty(){if(this._dirtyLevel===2||this._dirtyLevel===3){this._dirtyLevel=1;pauseTracking();for(let e=0;e<this._depsLength;e++){const t=this.deps[e];if(t.computed){triggerComputed(t.computed);if(this._dirtyLevel>=4)break}}this._dirtyLevel===1&&(this._dirtyLevel=0);resetTracking()}return this._dirtyLevel>=4}set dirty(e){this._dirtyLevel=e?4:0}run(){this._dirtyLevel=0;if(!this.active)return this.fn();let e=L;let t=D;try{L=true;D=this;this._runnings++;preCleanupEffect(this);return this.fn()}finally{postCleanupEffect(this);this._runnings--;D=t;L=e}}stop(){var e;if(this.active){preCleanupEffect(this);postCleanupEffect(this);(e=this.onStop)==null?void 0:e.call(this);this.active=false}}}function triggerComputed(e){return e.value}function preCleanupEffect(e){e._trackId++;e._depsLength=0}function postCleanupEffect(e){if(e.deps.length>e._depsLength){for(let t=e._depsLength;t<e.deps.length;t++)cleanupDepEffect(e.deps[t],e);e.deps.length=e._depsLength}}function cleanupDepEffect(e,t){const n=e.get(t);if(n!==void 0&&t._trackId!==n){e.delete(t);e.size===0&&e.cleanup()}}function effect(e,t){e.effect instanceof ReactiveEffect&&(e=e.effect.fn);const o=new ReactiveEffect(e,NOOP,(()=>{o.dirty&&o.run()}));if(t){n(o,t);t.scope&&recordEffectScope(o,t.scope)}t&&t.lazy||o.run();const r=o.run.bind(o);r.effect=o;return r}function stop(e){e.effect.stop()}let L=true;let H=0;const j=[];function pauseTracking(){j.push(L);L=false}function resetTracking(){const e=j.pop();L=e===void 0||e}function pauseScheduling(){H++}function resetScheduling(){H--;while(!H&&B.length)B.shift()()}function trackEffect(e,t,o){var r;if(t.get(e)!==e._trackId){t.set(e,e._trackId);const s=e.deps[e._depsLength];if(s!==t){s&&cleanupDepEffect(s,e);e.deps[e._depsLength++]=t}else e._depsLength++;(r=e.onTrack)==null?void 0:r.call(e,n({effect:e},o))}}const B=[];function triggerEffects(e,t,o){var r;pauseScheduling();for(const s of e.keys()){let i;if(s._dirtyLevel<t&&(i!=null?i:i=e.get(s)===s._trackId)){s._shouldSchedule||(s._shouldSchedule=s._dirtyLevel===0);s._dirtyLevel=t}if(s._shouldSchedule&&(i!=null?i:i=e.get(s)===s._trackId)){(r=s.onTrigger)==null?void 0:r.call(s,n({effect:s},o));s.trigger();if((!s._runnings||s.allowRecurse)&&s._dirtyLevel!==2){s._shouldSchedule=false;s.scheduler&&B.push(s.scheduler)}}}resetScheduling()}const createDep=(e,t)=>{const n=new Map;n.cleanup=e;n.computed=t;return n};const U=new WeakMap;const z=Symbol("iterate");const W=Symbol("Map key iterate");function track(e,t,n){if(L&&D){let o=U.get(e);o||U.set(e,o=new Map);let r=o.get(n);r||o.set(n,r=createDep((()=>o.delete(n))));trackEffect(D,r,{target:e,type:t,key:n})}}function trigger(e,t,n,o,s,i){const a=U.get(e);if(!a)return;let c=[];if(t==="clear")c=[...a.values()];else if(n==="length"&&r(e)){const e=Number(o);a.forEach(((t,n)=>{(n==="length"||!isSymbol(n)&&n>=e)&&c.push(t)}))}else{n!==void 0&&c.push(a.get(n));switch(t){case"add":if(r(e))isIntegerKey(n)&&c.push(a.get("length"));else{c.push(a.get(z));isMap(e)&&c.push(a.get(W))}break;case"delete":if(!r(e)){c.push(a.get(z));isMap(e)&&c.push(a.get(W))}break;case"set":isMap(e)&&c.push(a.get(z));break}}pauseScheduling();for(const r of c)r&&triggerEffects(r,4,{target:e,type:t,key:n,newValue:o,oldValue:s,oldTarget:i});resetScheduling()}function getDepFromReactive(e,t){var n;return(n=U.get(e))==null?void 0:n.get(t)}const q=makeMap("__proto__,__v_isRef,__isVue");const K=new Set(Object.getOwnPropertyNames(Symbol).filter((e=>e!=="arguments"&&e!=="caller")).map((e=>Symbol[e])).filter(isSymbol));const G=createArrayInstrumentations();function createArrayInstrumentations(){const e={};["includes","indexOf","lastIndexOf"].forEach((t=>{e[t]=function(...e){const n=toRaw(this);for(let e=0,t=this.length;e<t;e++)track(n,"get",e+"");const o=n[t](...e);return o===-1||o===false?n[t](...e.map(toRaw)):o}}));["push","pop","shift","unshift","splice"].forEach((t=>{e[t]=function(...e){pauseTracking();pauseScheduling();const n=toRaw(this)[t].apply(this,e);resetScheduling();resetTracking();return n}}));return e}function hasOwnProperty(e){isSymbol(e)||(e=String(e));const t=toRaw(this);track(t,"has",e);return t.hasOwnProperty(e)}class BaseReactiveHandler{constructor(e=false,t=false){this._isReadonly=e;this._isShallow=t}get(e,t,n){const o=this._isReadonly,s=this._isShallow;if(t==="__v_isReactive")return!o;if(t==="__v_isReadonly")return o;if(t==="__v_isShallow")return s;if(t==="__v_raw")return n===(o?s?ue:le:s?ce:ae).get(e)||Object.getPrototypeOf(e)===Object.getPrototypeOf(n)?e:void 0;const i=r(e);if(!o){if(i&&hasOwn(G,t))return Reflect.get(G,t,n);if(t==="hasOwnProperty")return hasOwnProperty}const a=Reflect.get(e,t,n);if(isSymbol(t)?K.has(t):q(t))return a;o||track(e,"get",t);return s?a:isRef(a)?i&&isIntegerKey(t)?a:a.value:isObject(a)?o?readonly(a):reactive(a):a}}class MutableReactiveHandler extends BaseReactiveHandler{constructor(e=false){super(false,e)}set(e,t,n,o){let s=e[t];if(!this._isShallow){const t=isReadonly(s);if(!isShallow(n)&&!isReadonly(n)){s=toRaw(s);n=toRaw(n)}if(!r(e)&&isRef(s)&&!isRef(n)){if(t)return false;s.value=n;return true}}const i=r(e)&&isIntegerKey(t)?Number(t)<e.length:hasOwn(e,t);const a=Reflect.set(e,t,n,o);e===toRaw(o)&&(i?hasChanged(n,s)&&trigger(e,"set",t,n,s):trigger(e,"add",t,n));return a}deleteProperty(e,t){const n=hasOwn(e,t);const o=e[t];const r=Reflect.deleteProperty(e,t);r&&n&&trigger(e,"delete",t,void 0,o);return r}has(e,t){const n=Reflect.has(e,t);isSymbol(t)&&K.has(t)||track(e,"has",t);return n}ownKeys(e){track(e,"iterate",r(e)?"length":z);return Reflect.ownKeys(e)}}class ReadonlyReactiveHandler extends BaseReactiveHandler{constructor(e=false){super(true,e)}set(e,t){warn$2(`Set operation on key "${String(t)}" failed: target is readonly.`,e);return true}deleteProperty(e,t){warn$2(`Delete operation on key "${String(t)}" failed: target is readonly.`,e);return true}}const J=new MutableReactiveHandler;const Y=new ReadonlyReactiveHandler;const X=new MutableReactiveHandler(true);const Q=new ReadonlyReactiveHandler(true);const toShallow=e=>e;const getProto=e=>Reflect.getPrototypeOf(e);function get(e,t,n=false,o=false){e=e.__v_raw;const r=toRaw(e);const s=toRaw(t);if(!n){hasChanged(t,s)&&track(r,"get",t);track(r,"get",s)}const{has:i}=getProto(r);const a=o?toShallow:n?toReadonly:toReactive;if(i.call(r,t))return a(e.get(t));if(i.call(r,s))return a(e.get(s));e!==r&&e.get(t)}function has(e,t=false){const n=this.__v_raw;const o=toRaw(n);const r=toRaw(e);if(!t){hasChanged(e,r)&&track(o,"has",e);track(o,"has",r)}return e===r?n.has(e):n.has(e)||n.has(r)}function size(e,t=false){e=e.__v_raw;!t&&track(toRaw(e),"iterate",z);return Reflect.get(e,"size",e)}function add(e){e=toRaw(e);const t=toRaw(this);const n=getProto(t);const o=n.has.call(t,e);if(!o){t.add(e);trigger(t,"add",e,e)}return this}function set(e,t){t=toRaw(t);const n=toRaw(this);const{has:o,get:r}=getProto(n);let s=o.call(n,e);if(s)checkIdentityKeys(n,o,e);else{e=toRaw(e);s=o.call(n,e)}const i=r.call(n,e);n.set(e,t);s?hasChanged(t,i)&&trigger(n,"set",e,t,i):trigger(n,"add",e,t);return this}function deleteEntry(e){const t=toRaw(this);const{has:n,get:o}=getProto(t);let r=n.call(t,e);if(r)checkIdentityKeys(t,n,e);else{e=toRaw(e);r=n.call(t,e)}const s=o?o.call(t,e):void 0;const i=t.delete(e);r&&trigger(t,"delete",e,void 0,s);return i}function clear(){const e=toRaw(this);const t=e.size!==0;const n=isMap(e)?new Map(e):new Set(e);const o=e.clear();t&&trigger(e,"clear",void 0,void 0,n);return o}function createForEach(e,t){return function forEach(n,o){const r=this;const s=r.__v_raw;const i=toRaw(s);const a=t?toShallow:e?toReadonly:toReactive;!e&&track(i,"iterate",z);return s.forEach(((e,t)=>n.call(o,a(e),a(t),r)))}}function createIterableMethod(e,t,n){return function(...o){const r=this.__v_raw;const s=toRaw(r);const i=isMap(s);const a=e==="entries"||e===Symbol.iterator&&i;const c=e==="keys"&&i;const l=r[e](...o);const u=n?toShallow:t?toReadonly:toReactive;!t&&track(s,"iterate",c?W:z);return{next(){const{value:e,done:t}=l.next();return t?{value:e,done:t}:{value:a?[u(e[0]),u(e[1])]:u(e),done:t}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(e){return function(...t){{const n=t[0]?`on key "${t[0]}" `:"";warn$2(`${d(e)} operation ${n}failed: target is readonly.`,toRaw(this))}return e!=="delete"&&(e==="clear"?void 0:this)}}function createInstrumentations(){const e={get(e){return get(this,e)},get size(){return size(this)},has:has,add:add,set:set,delete:deleteEntry,clear:clear,forEach:createForEach(false,false)};const t={get(e){return get(this,e,false,true)},get size(){return size(this)},has:has,add:add,set:set,delete:deleteEntry,clear:clear,forEach:createForEach(false,true)};const n={get(e){return get(this,e,true)},get size(){return size(this,true)},has(e){return has.call(this,e,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,false)};const o={get(e){return get(this,e,true,true)},get size(){return size(this,true)},has(e){return has.call(this,e,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,true)};const r=["keys","values","entries",Symbol.iterator];r.forEach((r=>{e[r]=createIterableMethod(r,false,false);n[r]=createIterableMethod(r,true,false);t[r]=createIterableMethod(r,false,true);o[r]=createIterableMethod(r,true,true)}));return[e,n,t,o]}const[Z,ee,te,ne]=createInstrumentations();function createInstrumentationGetter(e,t){const n=t?e?ne:te:e?ee:Z;return(t,o,r)=>o==="__v_isReactive"?!e:o==="__v_isReadonly"?e:o==="__v_raw"?t:Reflect.get(hasOwn(n,o)&&o in t?n:t,o,r)}const oe={get:createInstrumentationGetter(false,false)};const re={get:createInstrumentationGetter(false,true)};const se={get:createInstrumentationGetter(true,false)};const ie={get:createInstrumentationGetter(true,true)};function checkIdentityKeys(e,t,n){const o=toRaw(n);if(o!==n&&t.call(e,o)){const t=toRawType(e);warn$2(`Reactive ${t} contains both the raw and reactive versions of the same object${t==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const ae=new WeakMap;const ce=new WeakMap;const le=new WeakMap;const ue=new WeakMap;function targetTypeMap(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(e){return e.__v_skip||!Object.isExtensible(e)?0:targetTypeMap(toRawType(e))}function reactive(e){return isReadonly(e)?e:createReactiveObject(e,false,J,oe,ae)}function shallowReactive(e){return createReactiveObject(e,false,X,re,ce)}function readonly(e){return createReactiveObject(e,true,Y,se,le)}function shallowReadonly(e){return createReactiveObject(e,true,Q,ie,ue)}function createReactiveObject(e,t,n,o,r){if(!isObject(e)){warn$2(`value cannot be made reactive: ${String(e)}`);return e}if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const s=r.get(e);if(s)return s;const i=getTargetType(e);if(i===0)return e;const a=new Proxy(e,i===2?o:n);r.set(e,a);return a}function isReactive(e){return isReadonly(e)?isReactive(e.__v_raw):!!(e&&e.__v_isReactive)}function isReadonly(e){return!!(e&&e.__v_isReadonly)}function isShallow(e){return!!(e&&e.__v_isShallow)}function isProxy(e){return!!e&&!!e.__v_raw}function toRaw(e){const t=e&&e.__v_raw;return t?toRaw(t):e}function markRaw(e){Object.isExtensible(e)&&def(e,"__v_skip",true);return e}const toReactive=e=>isObject(e)?reactive(e):e;const toReadonly=e=>isObject(e)?readonly(e):e;const pe="Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free";class ComputedRefImpl{constructor(e,t,n,o){this.getter=e;this._setter=t;this.dep=void 0;this.__v_isRef=true;this.__v_isReadonly=false;this.effect=new ReactiveEffect((()=>e(this._value)),(()=>triggerRefValue(this,this.effect._dirtyLevel===2?2:3)));this.effect.computed=this;this.effect.active=this._cacheable=!o;this.__v_isReadonly=n}get value(){const e=toRaw(this);e._cacheable&&!e.effect.dirty||!hasChanged(e._value,e._value=e.effect.run())||triggerRefValue(e,4);trackRefValue(e);if(e.effect._dirtyLevel>=2){this._warnRecursive&&warn$2(pe,"\n\ngetter: ",this.getter);triggerRefValue(e,2)}return e._value}set value(e){this._setter(e)}get _dirty(){return this.effect.dirty}set _dirty(e){this.effect.dirty=e}}function computed$1(e,t,n=false){let o;let r;const s=isFunction(e);if(s){o=e;r=()=>{warn$2("Write operation failed: computed value is readonly")}}else{o=e.get;r=e.set}const i=new ComputedRefImpl(o,r,s||!r,n);if(t&&!n){i.effect.onTrack=t.onTrack;i.effect.onTrigger=t.onTrigger}return i}function trackRefValue(e){var t;if(L&&D){e=toRaw(e);trackEffect(D,(t=e.dep)!=null?t:e.dep=createDep((()=>e.dep=void 0),e instanceof ComputedRefImpl?e:void 0),{target:e,type:"get",key:"value"})}}function triggerRefValue(e,t=4,n){e=toRaw(e);const o=e.dep;o&&triggerEffects(o,t,{target:e,type:"set",key:"value",newValue:n})}function isRef(e){return!!(e&&e.__v_isRef===true)}function ref(e){return createRef(e,false)}function shallowRef(e){return createRef(e,true)}function createRef(e,t){return isRef(e)?e:new RefImpl(e,t)}class RefImpl{constructor(e,t){this.__v_isShallow=t;this.dep=void 0;this.__v_isRef=true;this._rawValue=t?e:toRaw(e);this._value=t?e:toReactive(e)}get value(){trackRefValue(this);return this._value}set value(e){const t=this.__v_isShallow||isShallow(e)||isReadonly(e);e=t?e:toRaw(e);if(hasChanged(e,this._rawValue)){this._rawValue=e;this._value=t?e:toReactive(e);triggerRefValue(this,4,e)}}}function triggerRef(e){triggerRefValue(e,4,e.value)}function unref(e){return isRef(e)?e.value:e}function toValue(e){return isFunction(e)?e():unref(e)}const de={get:(e,t,n)=>unref(Reflect.get(e,t,n)),set:(e,t,n,o)=>{const r=e[t];if(isRef(r)&&!isRef(n)){r.value=n;return true}return Reflect.set(e,t,n,o)}};function proxyRefs(e){return isReactive(e)?e:new Proxy(e,de)}class CustomRefImpl{constructor(e){this.dep=void 0;this.__v_isRef=true;const{get:t,set:n}=e((()=>trackRefValue(this)),(()=>triggerRefValue(this)));this._get=t;this._set=n}get value(){return this._get()}set value(e){this._set(e)}}function customRef(e){return new CustomRefImpl(e)}function toRefs(e){isProxy(e)||warn$2("toRefs() expects a reactive object but received a plain one.");const t=r(e)?new Array(e.length):{};for(const n in e)t[n]=propertyToRef(e,n);return t}class ObjectRefImpl{constructor(e,t,n){this._object=e;this._key=t;this._defaultValue=n;this.__v_isRef=true}get value(){const e=this._object[this._key];return e===void 0?this._defaultValue:e}set value(e){this._object[this._key]=e}get dep(){return getDepFromReactive(toRaw(this._object),this._key)}}class GetterRefImpl{constructor(e){this._getter=e;this.__v_isRef=true;this.__v_isReadonly=true}get value(){return this._getter()}}function toRef(e,t,n){return isRef(e)?e:isFunction(e)?new GetterRefImpl(e):isObject(e)&&arguments.length>1?propertyToRef(e,t,n):ref(e)}function propertyToRef(e,t,n){const o=e[t];return isRef(o)?o:new ObjectRefImpl(e,t,n)}const fe={GET:"get",HAS:"has",ITERATE:"iterate"};const he={SET:"set",ADD:"add",DELETE:"delete",CLEAR:"clear"};const me=[];function pushWarningContext(e){me.push(e)}function popWarningContext(){me.pop()}function warn$1(e,...t){pauseTracking();const n=me.length?me[me.length-1].component:null;const o=n&&n.appContext.config.warnHandler;const r=getComponentTrace();if(o)callWithErrorHandling(o,n,11,[e+t.map((e=>{var t,n;return(n=(t=e.toString)==null?void 0:t.call(e))!=null?n:JSON.stringify(e)})).join(""),n&&n.proxy,r.map((({vnode:e})=>`at <${formatComponentName(n,e.type)}>`)).join("\n"),r]);else{const n=[`[Vue warn]: ${e}`,...t];r.length&&true&&n.push("\n",...formatTrace(r));console.warn(...n)}resetTracking()}function getComponentTrace(){let e=me[me.length-1];if(!e)return[];const t=[];while(e){const n=t[0];n&&n.vnode===e?n.recurseCount++:t.push({vnode:e,recurseCount:0});const o=e.component&&e.component.parent;e=o&&o.vnode}return t}function formatTrace(e){const t=[];e.forEach(((e,n)=>{t.push(...n===0?[]:["\n"],...formatTraceEntry(e))}));return t}function formatTraceEntry({vnode:e,recurseCount:t}){const n=t>0?`... (${t} recursive calls)`:"";const o=!!e.component&&e.component.parent==null;const r=` at <${formatComponentName(e.component,e.type,o)}`;const s=">"+n;return e.props?[r,...formatProps(e.props),s]:[r+s]}function formatProps(e){const t=[];const n=Object.keys(e);n.slice(0,3).forEach((n=>{t.push(...formatProp(n,e[n]))}));n.length>3&&t.push(" ...");return t}function formatProp(e,t,n){if(isString(t)){t=JSON.stringify(t);return n?t:[`${e}=${t}`]}if(typeof t==="number"||typeof t==="boolean"||t==null)return n?t:[`${e}=${t}`];if(isRef(t)){t=formatProp(e,toRaw(t.value),true);return n?t:[`${e}=Ref<`,t,">"]}if(isFunction(t))return[`${e}=fn${t.name?`<${t.name}>`:""}`];t=toRaw(t);return n?t:[`${e}=`,t]}function assertNumber(e,t){e!==void 0&&(typeof e!=="number"?warn$1(`${t} is not a valid number - got ${JSON.stringify(e)}.`):isNaN(e)&&warn$1(`${t} is NaN - the duration expression might be incorrect.`))}const ge={SETUP_FUNCTION:0,0:"SETUP_FUNCTION",RENDER_FUNCTION:1,1:"RENDER_FUNCTION",WATCH_GETTER:2,2:"WATCH_GETTER",WATCH_CALLBACK:3,3:"WATCH_CALLBACK",WATCH_CLEANUP:4,4:"WATCH_CLEANUP",NATIVE_EVENT_HANDLER:5,5:"NATIVE_EVENT_HANDLER",COMPONENT_EVENT_HANDLER:6,6:"COMPONENT_EVENT_HANDLER",VNODE_HOOK:7,7:"VNODE_HOOK",DIRECTIVE_HOOK:8,8:"DIRECTIVE_HOOK",TRANSITION_HOOK:9,9:"TRANSITION_HOOK",APP_ERROR_HANDLER:10,10:"APP_ERROR_HANDLER",APP_WARN_HANDLER:11,11:"APP_WARN_HANDLER",FUNCTION_REF:12,12:"FUNCTION_REF",ASYNC_COMPONENT_LOADER:13,13:"ASYNC_COMPONENT_LOADER",SCHEDULER:14,14:"SCHEDULER"};const ye={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."};function callWithErrorHandling(e,t,n,o){try{return o?e(...o):e()}catch(e){handleError(e,t,n)}}function callWithAsyncErrorHandling(e,t,n,o){if(isFunction(e)){const r=callWithErrorHandling(e,t,n,o);r&&isPromise(r)&&r.catch((e=>{handleError(e,t,n)}));return r}if(r(e)){const r=[];for(let s=0;s<e.length;s++)r.push(callWithAsyncErrorHandling(e[s],t,n,o));return r}warn$1("Invalid value type passed to callWithAsyncErrorHandling(): "+typeof e)}function handleError(e,t,n,o=true){const r=t?t.vnode:null;if(t){let o=t.parent;const r=t.proxy;const s=ye[n];while(o){const t=o.ec;if(t)for(let n=0;n<t.length;n++)if(t[n](e,r,s)===false)return;o=o.parent}const i=t.appContext.config.errorHandler;if(i){pauseTracking();callWithErrorHandling(i,null,10,[e,r,s]);resetTracking();return}}logError(e,n,r,o)}function logError(e,t,n,o=true){{const r=ye[t];n&&pushWarningContext(n);warn$1("Unhandled error"+(r?` during execution of ${r}`:""));n&&popWarningContext();if(o)throw e;console.error(e)}}let ve=false;let be=false;const Ce=[];let Se=0;const xe=[];let we=null;let Ee=0;const ke=Promise.resolve();let _e=null;const Te=100;function nextTick(e){const t=_e||ke;return e?t.then(this?e.bind(this):e):t}function findInsertionIndex(e){let t=Se+1;let n=Ce.length;while(t<n){const o=t+n>>>1;const r=Ce[o];const s=getId(r);s<e||s===e&&r.pre?t=o+1:n=o}return t}function queueJob(e){if(!Ce.length||!Ce.includes(e,ve&&e.allowRecurse?Se+1:Se)){e.id==null?Ce.push(e):Ce.splice(findInsertionIndex(e.id),0,e);queueFlush()}}function queueFlush(){if(!ve&&!be){be=true;_e=ke.then(flushJobs)}}function invalidateJob(e){const t=Ce.indexOf(e);t>Se&&Ce.splice(t,1)}function queuePostFlushCb(e){r(e)?xe.push(...e):we&&we.includes(e,e.allowRecurse?Ee+1:Ee)||xe.push(e);queueFlush()}function flushPreFlushCbs(e,t,n=(ve?Se+1:0)){t=t||new Map;for(;n<Ce.length;n++){const o=Ce[n];if(o&&o.pre){if(e&&o.id!==e.uid)continue;if(checkRecursiveUpdates(t,o))continue;Ce.splice(n,1);n--;o()}}}function flushPostFlushCbs(e){if(xe.length){const t=[...new Set(xe)].sort(((e,t)=>getId(e)-getId(t)));xe.length=0;if(we){we.push(...t);return}we=t;e=e||new Map;for(Ee=0;Ee<we.length;Ee++)checkRecursiveUpdates(e,we[Ee])||we[Ee]();we=null;Ee=0}}const getId=e=>e.id==null?Infinity:e.id;const comparator=(e,t)=>{const n=getId(e)-getId(t);if(n===0){if(e.pre&&!t.pre)return-1;if(t.pre&&!e.pre)return 1}return n};function flushJobs(e){be=false;ve=true;e=e||new Map;Ce.sort(comparator);const check=t=>checkRecursiveUpdates(e,t);try{for(Se=0;Se<Ce.length;Se++){const e=Ce[Se];if(e&&e.active!==false){if(check(e))continue;callWithErrorHandling(e,null,14)}}}finally{Se=0;Ce.length=0;flushPostFlushCbs(e);ve=false;_e=null;(Ce.length||xe.length)&&flushJobs(e)}}function checkRecursiveUpdates(e,t){if(e.has(t)){const n=e.get(t);if(n>Te){const e=t.ownerInstance;const n=e&&getComponentName(e.type);handleError(`Maximum recursive updates exceeded${n?` in component <${n}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,null,10);return true}e.set(t,n+1)}else e.set(t,1)}let Ne=false;const Re=new Set;getGlobalThis().__VUE_HMR_RUNTIME__={createRecord:tryWrap(createRecord),rerender:tryWrap(rerender),reload:tryWrap(reload)};const Ae=new Map;function registerHMR(e){const t=e.type.__hmrId;let n=Ae.get(t);if(!n){createRecord(t,e.type);n=Ae.get(t)}n.instances.add(e)}function unregisterHMR(e){Ae.get(e.type.__hmrId).instances.delete(e)}function createRecord(e,t){if(Ae.has(e))return false;Ae.set(e,{initialDef:normalizeClassComponent(t),instances:new Set});return true}function normalizeClassComponent(e){return isClassComponent(e)?e.__vccOpts:e}function rerender(e,t){const n=Ae.get(e);if(n){n.initialDef.render=t;[...n.instances].forEach((e=>{if(t){e.render=t;normalizeClassComponent(e.type).render=t}e.renderCache=[];Ne=true;e.effect.dirty=true;e.update();Ne=false}))}}function reload(e,t){const n=Ae.get(e);if(!n)return;t=normalizeClassComponent(t);updateComponentDef(n.initialDef,t);const o=[...n.instances];for(const e of o){const o=normalizeClassComponent(e.type);if(!Re.has(o)){o!==n.initialDef&&updateComponentDef(o,t);Re.add(o)}e.appContext.propsCache.delete(e.type);e.appContext.emitsCache.delete(e.type);e.appContext.optionsCache.delete(e.type);if(e.ceReload){Re.add(o);e.ceReload(t.styles);Re.delete(o)}else if(e.parent){e.parent.effect.dirty=true;queueJob(e.parent.update)}else e.appContext.reload?e.appContext.reload():typeof window!=="undefined"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")}queuePostFlushCb((()=>{for(const e of o)Re.delete(normalizeClassComponent(e.type))}))}function updateComponentDef(e,t){n(e,t);for(const n in e)n==="__file"||n in t||delete e[n]}function tryWrap(e){return(t,n)=>{try{return e(t,n)}catch(e){console.error(e);console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}let $e;let Oe=[];let Ie=false;function emit$1(e,...t){$e?$e.emit(e,...t):Ie||Oe.push({event:e,args:t})}function setDevtoolsHook$1(e,t){var n,o;$e=e;if($e){$e.enabled=true;Oe.forEach((({event:e,args:t})=>$e.emit(e,...t)));Oe=[]}else if(typeof window!=="undefined"&&window.HTMLElement&&!((o=(n=window.navigator)==null?void 0:n.userAgent)==null?void 0:o.includes("jsdom"))){const e=t.__VUE_DEVTOOLS_HOOK_REPLAY__=t.__VUE_DEVTOOLS_HOOK_REPLAY__||[];e.push((e=>{setDevtoolsHook$1(e,t)}));setTimeout((()=>{if(!$e){t.__VUE_DEVTOOLS_HOOK_REPLAY__=null;Ie=true;Oe=[]}}),3e3)}else{Ie=true;Oe=[]}}function devtoolsInitApp(e,t){emit$1("app:init",e,t,{Fragment:Rt,Text:At,Comment:$t,Static:Ot})}function devtoolsUnmountApp(e){emit$1("app:unmount",e)}const Pe=createDevtoolsComponentHook("component:added");const Ve=createDevtoolsComponentHook("component:updated");const Me=createDevtoolsComponentHook("component:removed");const devtoolsComponentRemoved=e=>{$e&&typeof $e.cleanupBuffer==="function"&&!$e.cleanupBuffer(e)&&Me(e)};function createDevtoolsComponentHook(e){return t=>{emit$1(e,t.appContext.app,t.uid,t.parent?t.parent.uid:void 0,t)}}const Fe=createDevtoolsPerformanceHook("perf:start");const De=createDevtoolsPerformanceHook("perf:end");function createDevtoolsPerformanceHook(e){return(t,n,o)=>{emit$1(e,t.appContext.app,t.uid,t,n,o)}}function devtoolsComponentEmit(e,t,n){emit$1("component:emit",e.appContext.app,e,t,n)}function emit(t,n,...o){if(t.isUnmounted)return;const r=t.vnode.props||e;{const{emitsOptions:e,propsOptions:[r]}=t;if(e)if(!(n in e)&&true)r&&f(n)in r||warn$1(`Component emitted event "${n}" but it is neither declared in the emits option nor as an "${f(n)}" prop.`);else{const t=e[n];if(isFunction(t)){const e=t(...o);e||warn$1(`Invalid event arguments: event validation failed for event "${n}".`)}}}let s=o;const i=n.startsWith("update:");const a=i&&n.slice(7);if(a&&a in r){const t=`${a==="modelValue"?"model":a}Modifiers`;const{number:n,trim:i}=r[t]||e;i&&(s=o.map((e=>isString(e)?e.trim():e)));n&&(s=o.map(looseToNumber))}devtoolsComponentEmit(t,n,s);{const e=n.toLowerCase();e!==n&&r[f(e)]&&warn$1(`Event "${e}" is emitted in component ${formatComponentName(t,t.type)} but the handler is registered for "${n}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${p(n)}" instead of "${n}".`)}let c;let u=r[c=f(n)]||r[c=f(l(n))];!u&&i&&(u=r[c=f(p(n))]);u&&callWithAsyncErrorHandling(u,t,6,s);const d=r[c+"Once"];if(d){if(t.emitted){if(t.emitted[c])return}else t.emitted={};t.emitted[c]=true;callWithAsyncErrorHandling(d,t,6,s)}}function normalizeEmitsOptions(e,t,o=false){const s=t.emitsCache;const i=s.get(e);if(i!==void 0)return i;const a=e.emits;let c={};let l=false;if(!isFunction(e)){const extendEmits=e=>{const o=normalizeEmitsOptions(e,t,true);if(o){l=true;n(c,o)}};!o&&t.mixins.length&&t.mixins.forEach(extendEmits);e.extends&&extendEmits(e.extends);e.mixins&&e.mixins.forEach(extendEmits)}if(!a&&!l){isObject(e)&&s.set(e,null);return null}r(a)?a.forEach((e=>c[e]=null)):n(c,a);isObject(e)&&s.set(e,c);return c}function isEmitListener(e,t){if(!e||!isOn(t))return false;t=t.slice(2).replace(/Once$/,"");return hasOwn(e,t[0].toLowerCase()+t.slice(1))||hasOwn(e,p(t))||hasOwn(e,t)}let Le=null;let He=null;function setCurrentRenderingInstance(e){const t=Le;Le=e;He=e&&e.type.__scopeId||null;return t}function pushScopeId(e){He=e}function popScopeId(){He=null}const withScopeId=e=>withCtx;function withCtx(e,t=Le,n){if(!t)return e;if(e._n)return e;const renderFnWithContext=(...n)=>{renderFnWithContext._d&&setBlockTracking(-1);const o=setCurrentRenderingInstance(t);let r;try{r=e(...n)}finally{setCurrentRenderingInstance(o);renderFnWithContext._d&&setBlockTracking(1)}Ve(t);return r};renderFnWithContext._n=true;renderFnWithContext._c=true;renderFnWithContext._d=true;return renderFnWithContext}let je=false;function markAttrsAccessed(){je=true}function renderComponentRoot(e){const{type:t,vnode:n,proxy:o,withProxy:r,props:s,propsOptions:[i],slots:a,attrs:c,emit:l,render:u,renderCache:p,data:d,setupState:f,ctx:m,inheritAttrs:g}=e;let y;let v;const b=setCurrentRenderingInstance(e);je=false;try{if(n.shapeFlag&4){const e=r||o;const t=f.__isScriptSetup?new Proxy(e,{get(e,t,n){warn$1(`Property '${String(t)}' was accessed via 'this'. Avoid using 'this' in templates.`);return Reflect.get(e,t,n)}}):e;y=normalizeVNode(u.call(t,e,p,s,f,d,m));v=c}else{const e=t;c===s&&markAttrsAccessed();y=normalizeVNode(e.length>1?e(s,{get attrs(){markAttrsAccessed();return c},slots:a,emit:l}):e(s,null));v=t.props?c:getFunctionalFallthrough(c)}}catch(t){It.length=0;handleError(t,e,1);y=Ft($t)}let C=y;let S;y.patchFlag>0&&y.patchFlag&2048&&([C,S]=getChildRoot(y));if(v&&g!==false){const e=Object.keys(v);const{shapeFlag:t}=C;if(e.length)if(t&7){i&&e.some(isModelListener)&&(v=filterModelListeners(v,i));C=cloneVNode(C,v)}else if(!je&&C.type!==$t){const e=Object.keys(c);const t=[];const n=[];for(let o=0,r=e.length;o<r;o++){const r=e[o];isOn(r)?isModelListener(r)||t.push(r[2].toLowerCase()+r.slice(3)):n.push(r)}n.length&&warn$1(`Extraneous non-props attributes (${n.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);t.length&&warn$1(`Extraneous non-emits event listeners (${t.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`)}}if(n.dirs){isElementRoot(C)||warn$1("Runtime directive used on component with non-element root node. The directives will not function as intended.");C=cloneVNode(C);C.dirs=C.dirs?C.dirs.concat(n.dirs):n.dirs}if(n.transition){isElementRoot(C)||warn$1("Component inside <Transition> renders non-element root node that cannot be animated.");C.transition=n.transition}S?S(C):y=C;setCurrentRenderingInstance(b);return y}const getChildRoot=e=>{const t=e.children;const n=e.dynamicChildren;const o=filterSingleRoot(t,false);if(!o)return[e,void 0];if(o.patchFlag>0&&o.patchFlag&2048)return getChildRoot(o);const r=t.indexOf(o);const s=n?n.indexOf(o):-1;const setRoot=o=>{t[r]=o;n&&(s>-1?n[s]=o:o.patchFlag>0&&(e.dynamicChildren=[...n,o]))};return[normalizeVNode(o),setRoot]};function filterSingleRoot(e,t=true){let n;for(let o=0;o<e.length;o++){const r=e[o];if(!isVNode(r))return;if(r.type!==$t||r.children==="v-if"){if(n)return;n=r;if(t&&n.patchFlag>0&&n.patchFlag&2048)return filterSingleRoot(n.children)}}return n}const getFunctionalFallthrough=e=>{let t;for(const n in e)(n==="class"||n==="style"||isOn(n))&&((t||(t={}))[n]=e[n]);return t};const filterModelListeners=(e,t)=>{const n={};for(const o in e)isModelListener(o)&&o.slice(9)in t||(n[o]=e[o]);return n};const isElementRoot=e=>e.shapeFlag&7||e.type===$t;function shouldUpdateComponent(e,t,n){const{props:o,children:r,component:s}=e;const{props:i,children:a,patchFlag:c}=t;const l=s.emitsOptions;if((r||a)&&Ne)return true;if(t.dirs||t.transition)return true;if(!(n&&c>=0))return!(!r&&!a||a&&a.$stable)||o!==i&&(o?!i||hasPropsChanged(o,i,l):!!i);if(c&1024)return true;if(c&16)return o?hasPropsChanged(o,i,l):!!i;if(c&8){const e=t.dynamicProps;for(let t=0;t<e.length;t++){const n=e[t];if(i[n]!==o[n]&&!isEmitListener(l,n))return true}}return false}function hasPropsChanged(e,t,n){const o=Object.keys(t);if(o.length!==Object.keys(e).length)return true;for(let r=0;r<o.length;r++){const s=o[r];if(t[s]!==e[s]&&!isEmitListener(n,s))return true}return false}function updateHOCHostEl({vnode:e,parent:t},n){while(t){const o=t.subTree;o.suspense&&o.suspense.activeBranch===e&&(o.el=e.el);if(o!==e)break;(e=t.vnode).el=n;t=t.parent}}const Be="components";const Ue="directives";function resolveComponent(e,t){return resolveAsset(Be,e,true,t)||e}const ze=Symbol.for("v-ndc");function resolveDynamicComponent(e){return isString(e)?resolveAsset(Be,e,false)||e:e||ze}function resolveDirective(e){return resolveAsset(Ue,e)}function resolveAsset(e,t,n=true,o=false){const r=Le||Ht;if(r){const s=r.type;if(e===Be){const e=getComponentName(s,false);if(e&&(e===t||e===l(t)||e===d(l(t))))return s}const i=resolve(r[e]||s[e],t)||resolve(r.appContext[e],t);if(!i&&o)return s;if(n&&!i){const n=e===Be?"\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.":"";warn$1(`Failed to resolve ${e.slice(0,-1)}: ${t}${n}`)}return i}warn$1(`resolve${d(e.slice(0,-1))} can only be used in render() or setup().`)}function resolve(e,t){return e&&(e[t]||e[l(t)]||e[d(l(t))])}const isSuspense=e=>e.__isSuspense;let We=0;const qe={name:"Suspense",__isSuspense:true,process(e,t,n,o,r,s,i,a,c,l){if(e==null)mountSuspense(t,n,o,r,s,i,a,c,l);else{if(s&&s.deps>0&&!e.suspense.isInFallback){t.suspense=e.suspense;t.suspense.vnode=t;t.el=e.el;return}patchSuspense(e,t,n,o,r,i,a,c,l)}},hydrate:hydrateSuspense,create:createSuspenseBoundary,normalize:normalizeSuspenseChildren};const Ke=qe;function triggerEvent(e,t){const n=e.props&&e.props[t];isFunction(n)&&n()}function mountSuspense(e,t,n,o,r,s,i,a,c){const{p:l,o:{createElement:u}}=c;const p=u("div");const d=e.suspense=createSuspenseBoundary(e,r,o,t,p,n,s,i,a,c);l(null,d.pendingBranch=e.ssContent,p,null,o,d,s,i);if(d.deps>0){triggerEvent(e,"onPending");triggerEvent(e,"onFallback");l(null,e.ssFallback,t,n,o,null,s,i);setActiveBranch(d,e.ssFallback)}else d.resolve(false,true)}function patchSuspense(e,t,n,o,r,s,i,a,{p:c,um:l,o:{createElement:u}}){const p=t.suspense=e.suspense;p.vnode=t;t.el=e.el;const d=t.ssContent;const f=t.ssFallback;const{activeBranch:m,pendingBranch:g,isInFallback:y,isHydrating:v}=p;if(g){p.pendingBranch=d;if(isSameVNodeType(d,g)){c(g,d,p.hiddenContainer,null,r,p,s,i,a);if(p.deps<=0)p.resolve();else if(y&&!v){c(m,f,n,o,r,null,s,i,a);setActiveBranch(p,f)}}else{p.pendingId=We++;if(v){p.isHydrating=false;p.activeBranch=g}else l(g,r,p);p.deps=0;p.effects.length=0;p.hiddenContainer=u("div");if(y){c(null,d,p.hiddenContainer,null,r,p,s,i,a);if(p.deps<=0)p.resolve();else{c(m,f,n,o,r,null,s,i,a);setActiveBranch(p,f)}}else if(m&&isSameVNodeType(d,m)){c(m,d,n,o,r,p,s,i,a);p.resolve(true)}else{c(null,d,p.hiddenContainer,null,r,p,s,i,a);p.deps<=0&&p.resolve()}}}else if(m&&isSameVNodeType(d,m)){c(m,d,n,o,r,p,s,i,a);setActiveBranch(p,d)}else{triggerEvent(t,"onPending");p.pendingBranch=d;d.shapeFlag&512?p.pendingId=d.component.suspenseId:p.pendingId=We++;c(null,d,p.hiddenContainer,null,r,p,s,i,a);if(p.deps<=0)p.resolve();else{const{timeout:e,pendingId:t}=p;e>0?setTimeout((()=>{p.pendingId===t&&p.fallback(f)}),e):e===0&&p.fallback(f)}}}let Ge=false;function createSuspenseBoundary(e,t,n,o,r,s,i,a,c,l,u=false){if(!Ge){Ge=true;console[console.info?"info":"log"]("<Suspense> is an experimental feature and its API will likely change.")}const{p:p,m:d,um:f,n:m,o:{parentNode:g,remove:y}}=l;let v;const b=isVNodeSuspensible(e);if(b&&(t==null?void 0:t.pendingBranch)){v=t.pendingId;t.deps++}const C=e.props?toNumber(e.props.timeout):void 0;assertNumber(C,"Suspense timeout");const S=s;const x={vnode:e,parent:t,parentComponent:n,namespace:i,container:o,hiddenContainer:r,deps:0,pendingId:We++,timeout:typeof C==="number"?C:-1,activeBranch:null,pendingBranch:null,isInFallback:!u,isHydrating:u,isUnmounted:false,effects:[],resolve(e=false,n=false){if(!e&&!x.pendingBranch)throw new Error("suspense.resolve() is called without a pending branch.");if(x.isUnmounted)throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.");const{vnode:o,activeBranch:r,pendingBranch:i,pendingId:a,effects:c,parentComponent:l,container:u}=x;let p=false;if(x.isHydrating)x.isHydrating=false;else if(!e){p=r&&i.transition&&i.transition.mode==="out-in";p&&(r.transition.afterLeave=()=>{if(a===x.pendingId){d(i,u,s===S?m(r):s,0);queuePostFlushCb(c)}});if(r){g(r.el)!==x.hiddenContainer&&(s=m(r));f(r,l,x,true)}p||d(i,u,s,0)}setActiveBranch(x,i);x.pendingBranch=null;x.isInFallback=false;let y=x.parent;let C=false;while(y){if(y.pendingBranch){y.effects.push(...c);C=true;break}y=y.parent}C||p||queuePostFlushCb(c);x.effects=[];if(b&&t&&t.pendingBranch&&v===t.pendingId){t.deps--;t.deps!==0||n||t.resolve()}triggerEvent(o,"onResolve")},fallback(e){if(!x.pendingBranch)return;const{vnode:t,activeBranch:n,parentComponent:o,container:r,namespace:s}=x;triggerEvent(t,"onFallback");const i=m(n);const mountFallback=()=>{if(x.isInFallback){p(null,e,r,i,o,null,s,a,c);setActiveBranch(x,e)}};const l=e.transition&&e.transition.mode==="out-in";l&&(n.transition.afterLeave=mountFallback);x.isInFallback=true;f(n,o,null,true);l||mountFallback()},move(e,t,n){x.activeBranch&&d(x.activeBranch,e,t,n);x.container=e},next(){return x.activeBranch&&m(x.activeBranch)},registerDep(e,t){const n=!!x.pendingBranch;n&&x.deps++;const o=e.vnode.el;e.asyncDep.catch((t=>{handleError(t,e,0)})).then((r=>{if(e.isUnmounted||x.isUnmounted||x.pendingId!==e.suspenseId)return;e.asyncResolved=true;const{vnode:s}=e;pushWarningContext(s);handleSetupResult(e,r,false);o&&(s.el=o);const a=!o&&e.subTree.el;t(e,s,g(o||e.subTree.el),o?null:m(e.subTree),x,i,c);a&&y(a);updateHOCHostEl(e,s.el);popWarningContext();n&&--x.deps===0&&x.resolve()}))},unmount(e,t){x.isUnmounted=true;x.activeBranch&&f(x.activeBranch,n,e,t);x.pendingBranch&&f(x.pendingBranch,n,e,t)}};return x}function hydrateSuspense(e,t,n,o,r,s,i,a,c){const l=t.suspense=createSuspenseBoundary(t,o,n,e.parentNode,document.createElement("div"),null,r,s,i,a,true);const u=c(e,l.pendingBranch=t.ssContent,n,l,s,i);l.deps===0&&l.resolve(false,true);return u}function normalizeSuspenseChildren(e){const{shapeFlag:t,children:n}=e;const o=t&32;e.ssContent=normalizeSuspenseSlot(o?n.default:n);e.ssFallback=o?normalizeSuspenseSlot(n.fallback):Ft($t)}function normalizeSuspenseSlot(e){let t;if(isFunction(e)){const n=Vt&&e._c;if(n){e._d=false;openBlock()}e=e();if(n){e._d=true;t=Pt;closeBlock()}}if(r(e)){const t=filterSingleRoot(e);!t&&e.filter((e=>e!==ze)).length>0&&warn$1("<Suspense> slots expect a single root node.");e=t}e=normalizeVNode(e);t&&!e.dynamicChildren&&(e.dynamicChildren=t.filter((t=>t!==e)));return e}function queueEffectWithSuspense(e,t){t&&t.pendingBranch?r(e)?t.effects.push(...e):t.effects.push(e):queuePostFlushCb(e)}function setActiveBranch(e,t){e.activeBranch=t;const{vnode:n,parentComponent:o}=e;let r=t.el;while(!r&&t.component){t=t.component.subTree;r=t.el}n.el=r;if(o&&o.subTree===n){o.vnode.el=r;updateHOCHostEl(o,r)}}function isVNodeSuspensible(e){var t;return((t=e.props)==null?void 0:t.suspensible)!=null&&e.props.suspensible!==false}const Je=Symbol.for("v-scx");const useSSRContext=()=>{{const e=inject(Je);e||warn$1("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.");return e}};function watchEffect(e,t){return doWatch(e,null,t)}function watchPostEffect(e,t){return doWatch(e,null,n({},t,{flush:"post"}))}function watchSyncEffect(e,t){return doWatch(e,null,n({},t,{flush:"sync"}))}const Ye={};function watch(e,t,n){isFunction(t)||warn$1("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature.");return doWatch(e,t,n)}function doWatch(t,n,{immediate:o,deep:s,flush:i,once:a,onTrack:c,onTrigger:l}=e){if(n&&a){const e=n;n=(...t)=>{e(...t);unwatch()}}s!==void 0&&typeof s==="number"&&warn$1('watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.');if(!n){o!==void 0&&warn$1('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.');s!==void 0&&warn$1('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.');a!==void 0&&warn$1('watch() "once" option is only respected when using the watch(source, callback, options?) signature.')}const warnInvalidSource=e=>{warn$1("Invalid watch source: ",e,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")};const u=Ht;const reactiveGetter=e=>s===true?e:traverse(e,s===false?1:void 0);let p;let d=false;let f=false;if(isRef(t)){p=()=>t.value;d=isShallow(t)}else if(isReactive(t)){p=()=>reactiveGetter(t);d=true}else if(r(t)){f=true;d=t.some((e=>isReactive(e)||isShallow(e)));p=()=>t.map((e=>{if(isRef(e))return e.value;if(isReactive(e))return reactiveGetter(e);if(isFunction(e))return callWithErrorHandling(e,u,2);warnInvalidSource(e)}))}else if(isFunction(t))p=n?()=>callWithErrorHandling(t,u,2):()=>{m&&m();return callWithAsyncErrorHandling(t,u,3,[onCleanup])};else{p=NOOP;warnInvalidSource(t)}if(n&&s){const e=p;p=()=>traverse(e())}let m;let onCleanup=e=>{m=v.onStop=()=>{callWithErrorHandling(e,u,4);m=v.onStop=void 0}};let g=f?new Array(t.length).fill(Ye):Ye;const job=()=>{if(v.active&&v.dirty)if(n){const e=v.run();if(s||d||(f?e.some(((e,t)=>hasChanged(e,g[t]))):hasChanged(e,g))||false){m&&m();callWithAsyncErrorHandling(n,u,3,[e,g===Ye?void 0:f&&g[0]===Ye?[]:g,onCleanup]);g=e}}else v.run()};job.allowRecurse=!!n;let y;if(i==="sync")y=job;else if(i==="post")y=()=>_t(job,u&&u.suspense);else{job.pre=true;u&&(job.id=u.uid);y=()=>queueJob(job)}const v=new ReactiveEffect(p,NOOP,y);const b=getCurrentScope();const unwatch=()=>{v.stop();b&&remove(b.effects,v)};v.onTrack=c;v.onTrigger=l;n?o?job():g=v.run():i==="post"?_t(v.run.bind(v),u&&u.suspense):v.run();return unwatch}function instanceWatch(e,t,n){const o=this.proxy;const r=isString(e)?e.includes(".")?createPathGetter(o,e):()=>o[e]:e.bind(o,o);let s;if(isFunction(t))s=t;else{s=t.handler;n=t}const i=setCurrentInstance(this);const a=doWatch(r,s.bind(o),n);i();return a}function createPathGetter(e,t){const n=t.split(".");return()=>{let t=e;for(let e=0;e<n.length&&t;e++)t=t[n[e]];return t}}function traverse(e,t,n=0,o){if(!isObject(e)||e.__v_skip)return e;if(t&&t>0){if(n>=t)return e;n++}o=o||new Set;if(o.has(e))return e;o.add(e);if(isRef(e))traverse(e.value,t,n,o);else if(r(e))for(let r=0;r<e.length;r++)traverse(e[r],t,n,o);else if(isSet(e)||isMap(e))e.forEach((e=>{traverse(e,t,n,o)}));else if(isPlainObject(e))for(const r in e)traverse(e[r],t,n,o);return e}function validateDirectiveName(e){a(e)&&warn$1("Do not use built-in directive ids as custom directive id: "+e)}function withDirectives(t,n){if(Le===null){warn$1("withDirectives can only be used inside render functions.");return t}const o=getExposeProxy(Le)||Le.proxy;const r=t.dirs||(t.dirs=[]);for(let t=0;t<n.length;t++){let[s,i,a,c=e]=n[t];if(s){isFunction(s)&&(s={mounted:s,updated:s});s.deep&&traverse(i);r.push({dir:s,instance:o,value:i,oldValue:void 0,arg:a,modifiers:c})}}return t}function invokeDirectiveHook(e,t,n,o){const r=e.dirs;const s=t&&t.dirs;for(let i=0;i<r.length;i++){const a=r[i];s&&(a.oldValue=s[i].value);let c=a.dir[o];if(c){pauseTracking();callWithAsyncErrorHandling(c,n,8,[e.el,a,e,t]);resetTracking()}}}const Xe=Symbol("_leaveCb");const Qe=Symbol("_enterCb");function useTransitionState(){const e={isMounted:false,isLeaving:false,isUnmounting:false,leavingVNodes:new Map};it((()=>{e.isMounted=true}));lt((()=>{e.isUnmounting=true}));return e}const Ze=[Function,Array];const et={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Ze,onEnter:Ze,onAfterEnter:Ze,onEnterCancelled:Ze,onBeforeLeave:Ze,onLeave:Ze,onAfterLeave:Ze,onLeaveCancelled:Ze,onBeforeAppear:Ze,onAppear:Ze,onAfterAppear:Ze,onAppearCancelled:Ze};const tt={name:"BaseTransition",props:et,setup(e,{slots:t}){const n=getCurrentInstance();const o=useTransitionState();return()=>{const r=t.default&&getTransitionRawChildren(t.default(),true);if(!r||!r.length)return;let s=r[0];if(r.length>1){let e=false;for(const t of r)if(t.type!==$t){if(e){warn$1("<transition> can only be used on a single element or component. Use <transition-group> for lists.");break}s=t;e=true}}const i=toRaw(e);const{mode:a}=i;a&&a!=="in-out"&&a!=="out-in"&&a!=="default"&&warn$1(`invalid <transition> mode: ${a}`);if(o.isLeaving)return emptyPlaceholder(s);const c=getKeepAliveChild(s);if(!c)return emptyPlaceholder(s);const l=resolveTransitionHooks(c,i,o,n);setTransitionHooks(c,l);const u=n.subTree;const p=u&&getKeepAliveChild(u);if(p&&p.type!==$t&&!isSameVNodeType(c,p)){const e=resolveTransitionHooks(p,i,o,n);setTransitionHooks(p,e);if(a==="out-in"){o.isLeaving=true;e.afterLeave=()=>{o.isLeaving=false;if(n.update.active!==false){n.effect.dirty=true;n.update()}};return emptyPlaceholder(s)}a==="in-out"&&c.type!==$t&&(e.delayLeave=(e,t,n)=>{const r=getLeavingNodesForType(o,p);r[String(p.key)]=p;e[Xe]=()=>{t();e[Xe]=void 0;delete l.delayedLeave};l.delayedLeave=n})}return s}}};const nt=tt;function getLeavingNodesForType(e,t){const{leavingVNodes:n}=e;let o=n.get(t.type);if(!o){o=Object.create(null);n.set(t.type,o)}return o}function resolveTransitionHooks(e,t,n,o){const{appear:s,mode:i,persisted:a=false,onBeforeEnter:c,onEnter:l,onAfterEnter:u,onEnterCancelled:p,onBeforeLeave:d,onLeave:f,onAfterLeave:m,onLeaveCancelled:g,onBeforeAppear:y,onAppear:v,onAfterAppear:b,onAppearCancelled:C}=t;const S=String(e.key);const x=getLeavingNodesForType(n,e);const callHook=(e,t)=>{e&&callWithAsyncErrorHandling(e,o,9,t)};const callAsyncHook=(e,t)=>{const n=t[1];callHook(e,t);r(e)?e.every((e=>e.length<=1))&&n():e.length<=1&&n()};const w={mode:i,persisted:a,beforeEnter(t){let o=c;if(!n.isMounted){if(!s)return;o=y||c}t[Xe]&&t[Xe](true);const r=x[S];r&&isSameVNodeType(e,r)&&r.el[Xe]&&r.el[Xe]();callHook(o,[t])},enter(e){let t=l;let o=u;let r=p;if(!n.isMounted){if(!s)return;t=v||l;o=b||u;r=C||p}let i=false;const a=e[Qe]=t=>{if(!i){i=true;callHook(t?r:o,[e]);w.delayedLeave&&w.delayedLeave();e[Qe]=void 0}};t?callAsyncHook(t,[e,a]):a()},leave(t,o){const r=String(e.key);t[Qe]&&t[Qe](true);if(n.isUnmounting)return o();callHook(d,[t]);let s=false;const i=t[Xe]=n=>{if(!s){s=true;o();callHook(n?g:m,[t]);t[Xe]=void 0;x[r]===e&&delete x[r]}};x[r]=e;f?callAsyncHook(f,[t,i]):i()},clone(e){return resolveTransitionHooks(e,t,n,o)}};return w}function emptyPlaceholder(e){if(isKeepAlive(e)){e=cloneVNode(e);e.children=null;return e}}function getKeepAliveChild(e){return isKeepAlive(e)?e.component?e.component.subTree:e.children?e.children[0]:void 0:e}function setTransitionHooks(e,t){if(e.shapeFlag&6&&e.component)setTransitionHooks(e.component.subTree,t);else if(e.shapeFlag&128){e.ssContent.transition=t.clone(e.ssContent);e.ssFallback.transition=t.clone(e.ssFallback)}else e.transition=t}function getTransitionRawChildren(e,t=false,n){let o=[];let r=0;for(let s=0;s<e.length;s++){let i=e[s];const a=n==null?i.key:String(n)+String(i.key!=null?i.key:s);if(i.type===Rt){i.patchFlag&128&&r++;o=o.concat(getTransitionRawChildren(i.children,t,a))}else(t||i.type!==$t)&&o.push(a!=null?cloneVNode(i,{key:a}):i)}if(r>1)for(let e=0;e<o.length;e++)o[e].patchFlag=-2;return o}function defineComponent(e,t){return isFunction(e)?(()=>n({name:e.name},t,{setup:e}))():e}const isAsyncWrapper=e=>!!e.type.__asyncLoader;function defineAsyncComponent(e){isFunction(e)&&(e={loader:e});const{loader:t,loadingComponent:n,errorComponent:o,delay:r=200,timeout:s,suspensible:i=true,onError:a}=e;let c=null;let l;let u=0;const retry=()=>{u++;c=null;return load()};const load=()=>{let e;return c||(e=c=t().catch((e=>{e=e instanceof Error?e:new Error(String(e));if(a)return new Promise(((t,n)=>{const userRetry=()=>t(retry());const userFail=()=>n(e);a(e,userRetry,userFail,u+1)}));throw e})).then((t=>{if(e!==c&&c)return c;t||warn$1("Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.");t&&(t.__esModule||t[Symbol.toStringTag]==="Module")&&(t=t.default);if(t&&!isObject(t)&&!isFunction(t))throw new Error(`Invalid async component load result: ${t}`);l=t;return t})))};return defineComponent({name:"AsyncComponentWrapper",__asyncLoader:load,get __asyncResolved(){return l},setup(){const e=Ht;if(l)return()=>createInnerComp(l,e);const onError=t=>{c=null;handleError(t,e,13,!o)};if(i&&e.suspense||false)return load().then((t=>()=>createInnerComp(t,e))).catch((e=>{onError(e);return()=>o?Ft(o,{error:e}):null}));const t=ref(false);const a=ref();const u=ref(!!r);r&&setTimeout((()=>{u.value=false}),r);s!=null&&setTimeout((()=>{if(!t.value&&!a.value){const e=new Error(`Async component timed out after ${s}ms.`);onError(e);a.value=e}}),s);load().then((()=>{t.value=true;if(e.parent&&isKeepAlive(e.parent.vnode)){e.parent.effect.dirty=true;queueJob(e.parent.update)}})).catch((e=>{onError(e);a.value=e}));return()=>t.value&&l?createInnerComp(l,e):a.value&&o?Ft(o,{error:a.value}):n&&!u.value?Ft(n):void 0}})}function createInnerComp(e,t){const{ref:n,props:o,children:r,ce:s}=t.vnode;const i=Ft(e,o,r);i.ref=n;i.ce=s;delete t.vnode.ce;return i}const isKeepAlive=e=>e.type.__isKeepAlive;const ot={name:"KeepAlive",__isKeepAlive:true,props:{include:[String,RegExp,Array],exclude:[String,RegExp,Array],max:[String,Number]},setup(e,{slots:t}){const n=getCurrentInstance();const o=n.ctx;const r=new Map;const s=new Set;let i=null;n.__v_cache=r;const a=n.suspense;const{renderer:{p:c,m:l,um:u,o:{createElement:p}}}=o;const d=p("div");o.activate=(e,t,n,o,r)=>{const s=e.component;l(e,t,n,0,a);c(s.vnode,e,t,n,s,a,o,e.slotScopeIds,r);_t((()=>{s.isDeactivated=false;s.a&&invokeArrayFns(s.a);const t=e.props&&e.props.onVnodeMounted;t&&invokeVNodeHook(t,s.parent,e)}),a);Pe(s)};o.deactivate=e=>{const t=e.component;l(e,d,null,1,a);_t((()=>{t.da&&invokeArrayFns(t.da);const n=e.props&&e.props.onVnodeUnmounted;n&&invokeVNodeHook(n,t.parent,e);t.isDeactivated=true}),a);Pe(t)};function unmount(e){resetShapeFlag(e);u(e,n,a,true)}function pruneCache(e){r.forEach(((t,n)=>{const o=getComponentName(t.type);!o||e&&e(o)||pruneCacheEntry(n)}))}function pruneCacheEntry(e){const t=r.get(e);i&&isSameVNodeType(t,i)?i&&resetShapeFlag(i):unmount(t);r.delete(e);s.delete(e)}watch((()=>[e.include,e.exclude]),(([e,t])=>{e&&pruneCache((t=>matches(e,t)));t&&pruneCache((e=>!matches(t,e)))}),{flush:"post",deep:true});let f=null;const cacheSubtree=()=>{f!=null&&r.set(f,getInnerChild(n.subTree))};it(cacheSubtree);ct(cacheSubtree);lt((()=>{r.forEach((e=>{const{subTree:t,suspense:o}=n;const r=getInnerChild(t);if(e.type!==r.type||e.key!==r.key)unmount(e);else{resetShapeFlag(r);const e=r.component.da;e&&_t(e,o)}}))}));return()=>{f=null;if(!t.default)return i=null;const n=t.default();const o=n[0];if(n.length>1){warn$1("KeepAlive should contain exactly one component child.");i=null;return n}if(!isVNode(o)||!(o.shapeFlag&4)&&!(o.shapeFlag&128)){i=null;return o}let a=getInnerChild(o);const c=a.type;const l=getComponentName(isAsyncWrapper(a)?a.type.__asyncResolved||{}:c);const{include:u,exclude:p,max:d}=e;if(u&&(!l||!matches(u,l))||p&&l&&matches(p,l)){i=a;return o}const m=a.key==null?c:a.key;const g=r.get(m);if(a.el){a=cloneVNode(a);o.shapeFlag&128&&(o.ssContent=a)}f=m;if(g){a.el=g.el;a.component=g.component;a.transition&&setTransitionHooks(a,a.transition);a.shapeFlag|=512;s.delete(m);s.add(m)}else{s.add(m);d&&s.size>parseInt(d,10)&&pruneCacheEntry(s.values().next().value)}a.shapeFlag|=256;i=a;return isSuspense(o.type)?o:a}}};const rt=ot;function matches(e,t){return r(e)?e.some((e=>matches(e,t))):isString(e)?e.split(",").includes(t):!!isRegExp(e)&&e.test(t)}function onActivated(e,t){registerKeepAliveHook(e,"a",t)}function onDeactivated(e,t){registerKeepAliveHook(e,"da",t)}function registerKeepAliveHook(e,t,n=Ht){const o=e.__wdc||(e.__wdc=()=>{let t=n;while(t){if(t.isDeactivated)return;t=t.parent}return e()});injectHook(t,o,n);if(n){let e=n.parent;while(e&&e.parent){isKeepAlive(e.parent.vnode)&&injectToKeepAliveRoot(o,t,n,e);e=e.parent}}}function injectToKeepAliveRoot(e,t,n,o){const r=injectHook(t,e,o,true);ut((()=>{remove(o[t],r)}),n)}function resetShapeFlag(e){e.shapeFlag&=-257;e.shapeFlag&=-513}function getInnerChild(e){return e.shapeFlag&128?e.ssContent:e}function injectHook(e,t,n=Ht,o=false){if(n){const r=n[e]||(n[e]=[]);const s=t.__weh||(t.__weh=(...o)=>{if(n.isUnmounted)return;pauseTracking();const r=setCurrentInstance(n);const s=callWithAsyncErrorHandling(t,n,e,o);r();resetTracking();return s});o?r.unshift(s):r.push(s);return s}{const t=f(ye[e].replace(/ hook$/,""));warn$1(`${t} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`)}}const createHook=e=>(t,n=Ht)=>(!zt||e==="sp")&&injectHook(e,((...e)=>t(...e)),n);const st=createHook("bm");const it=createHook("m");const at=createHook("bu");const ct=createHook("u");const lt=createHook("bum");const ut=createHook("um");const pt=createHook("sp");const dt=createHook("rtg");const ft=createHook("rtc");function onErrorCaptured(e,t=Ht){injectHook("ec",e,t)}function renderList(e,t,n,o){let s;const i=n&&n[o];if(r(e)||isString(e)){s=new Array(e.length);for(let n=0,o=e.length;n<o;n++)s[n]=t(e[n],n,void 0,i&&i[n])}else if(typeof e==="number"){Number.isInteger(e)||warn$1(`The v-for range expect an integer value but got ${e}.`);s=new Array(e);for(let n=0;n<e;n++)s[n]=t(n+1,n,void 0,i&&i[n])}else if(isObject(e))if(e[Symbol.iterator])s=Array.from(e,((e,n)=>t(e,n,void 0,i&&i[n])));else{const n=Object.keys(e);s=new Array(n.length);for(let o=0,r=n.length;o<r;o++){const r=n[o];s[o]=t(e[r],r,o,i&&i[o])}}else s=[];n&&(n[o]=s);return s}function createSlots(e,t){for(let n=0;n<t.length;n++){const o=t[n];if(r(o))for(let t=0;t<o.length;t++)e[o[t].name]=o[t].fn;else o&&(e[o.name]=o.key?(...e)=>{const t=o.fn(...e);t&&(t.key=o.key);return t}:o.fn)}return e}function renderSlot(e,t,n={},o,r){if(Le.isCE||Le.parent&&isAsyncWrapper(Le.parent)&&Le.parent.isCE){t!=="default"&&(n.name=t);return Ft("slot",n,o&&o())}let s=e[t];if(s&&s.length>1){warn$1("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.");s=()=>[]}s&&s._c&&(s._d=false);openBlock();const i=s&&ensureValidVNode(s(n));const a=createBlock(Rt,{key:n.key||i&&i.key||`_${t}`},i||(o?o():[]),i&&e._===1?64:-2);!r&&a.scopeId&&(a.slotScopeIds=[a.scopeId+"-s"]);s&&s._c&&(s._d=true);return a}function ensureValidVNode(e){return e.some((e=>!isVNode(e)||e.type!==$t&&!(e.type===Rt&&!ensureValidVNode(e.children))))?e:null}function toHandlers(e,t){const n={};if(!isObject(e)){warn$1("v-on with no argument expects an object value.");return n}for(const o in e)n[t&&/[A-Z]/.test(o)?`on:${o}`:f(o)]=e[o];return n}const getPublicInstance=e=>e?isStatefulComponent(e)?getExposeProxy(e)||e.proxy:getPublicInstance(e.parent):null;const ht=n(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>shallowReadonly(e.props),$attrs:e=>shallowReadonly(e.attrs),$slots:e=>shallowReadonly(e.slots),$refs:e=>shallowReadonly(e.refs),$parent:e=>getPublicInstance(e.parent),$root:e=>getPublicInstance(e.root),$emit:e=>e.emit,$options:e=>resolveMergedOptions(e),$forceUpdate:e=>e.f||(e.f=()=>{e.effect.dirty=true;queueJob(e.update)}),$nextTick:e=>e.n||(e.n=nextTick.bind(e.proxy)),$watch:e=>instanceWatch.bind(e)});const isReservedPrefix=e=>e==="_"||e==="$";const hasSetupBinding=(t,n)=>t!==e&&!t.__isScriptSetup&&hasOwn(t,n);const mt={get({_:t},n){if(n==="__v_skip")return true;const{ctx:o,setupState:r,data:s,props:i,accessCache:a,type:c,appContext:l}=t;if(n==="__isVue")return true;let u;if(n[0]!=="$"){const c=a[n];if(c!==void 0)switch(c){case 1:return r[n];case 2:return s[n];case 4:return o[n];case 3:return i[n]}else{if(hasSetupBinding(r,n)){a[n]=1;return r[n]}if(s!==e&&hasOwn(s,n)){a[n]=2;return s[n]}if((u=t.propsOptions[0])&&hasOwn(u,n)){a[n]=3;return i[n]}if(o!==e&&hasOwn(o,n)){a[n]=4;return o[n]}yt&&(a[n]=0)}}const p=ht[n];let d,f;if(p){if(n==="$attrs"){track(t.attrs,"get","");markAttrsAccessed()}else n==="$slots"&&track(t,"get",n);return p(t)}if((d=c.__cssModules)&&(d=d[n]))return d;if(o!==e&&hasOwn(o,n)){a[n]=4;return o[n]}if(f=l.config.globalProperties,hasOwn(f,n))return f[n];!Le||isString(n)&&n.indexOf("__v")===0||(s!==e&&isReservedPrefix(n[0])&&hasOwn(s,n)?warn$1(`Property ${JSON.stringify(n)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`):t===Le&&warn$1(`Property ${JSON.stringify(n)} was accessed during render but is not defined on instance.`))},set({_:t},n,o){const{data:r,setupState:s,ctx:i}=t;if(hasSetupBinding(s,n)){s[n]=o;return true}if(s.__isScriptSetup&&hasOwn(s,n)){warn$1(`Cannot mutate <script setup> binding "${n}" from Options API.`);return false}if(r!==e&&hasOwn(r,n)){r[n]=o;return true}if(hasOwn(t.props,n)){warn$1(`Attempting to mutate prop "${n}". Props are readonly.`);return false}if(n[0]==="$"&&n.slice(1)in t){warn$1(`Attempting to mutate public property "${n}". Properties starting with $ are reserved and readonly.`);return false}n in t.appContext.config.globalProperties?Object.defineProperty(i,n,{enumerable:true,configurable:true,value:o}):i[n]=o;return true},has({_:{data:t,setupState:n,accessCache:o,ctx:r,appContext:s,propsOptions:i}},a){let c;return!!o[a]||t!==e&&hasOwn(t,a)||hasSetupBinding(n,a)||(c=i[0])&&hasOwn(c,a)||hasOwn(r,a)||hasOwn(ht,a)||hasOwn(s.config.globalProperties,a)},defineProperty(e,t,n){n.get!=null?e._.accessCache[t]=0:hasOwn(n,"value")&&this.set(e,t,n.value,null);return Reflect.defineProperty(e,t,n)}};mt.ownKeys=e=>{warn$1("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.");return Reflect.ownKeys(e)};const gt=n({},mt,{get(e,t){if(t!==Symbol.unscopables)return mt.get(e,t,e)},has(e,t){const n=t[0]!=="_"&&!b(t);!n&&mt.has(e,t)&&warn$1(`Property ${JSON.stringify(t)} should not start with _ which is a reserved prefix for Vue internals.`);return n}});function createDevRenderContext(e){const t={};Object.defineProperty(t,"_",{configurable:true,enumerable:false,get:()=>e});Object.keys(ht).forEach((n=>{Object.defineProperty(t,n,{configurable:true,enumerable:false,get:()=>ht[n](e),set:NOOP})}));return t}function exposePropsOnRenderContext(e){const{ctx:t,propsOptions:[n]}=e;n&&Object.keys(n).forEach((n=>{Object.defineProperty(t,n,{enumerable:true,configurable:true,get:()=>e.props[n],set:NOOP})}))}function exposeSetupStateOnRenderContext(e){const{ctx:t,setupState:n}=e;Object.keys(toRaw(n)).forEach((e=>{if(!n.__isScriptSetup){if(isReservedPrefix(e[0])){warn$1(`setup() return property ${JSON.stringify(e)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);return}Object.defineProperty(t,e,{enumerable:true,configurable:true,get:()=>n[e],set:NOOP})}}))}const warnRuntimeUsage=e=>warn$1(`${e}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);function defineProps(){warnRuntimeUsage("defineProps");return null}function defineEmits(){warnRuntimeUsage("defineEmits");return null}function defineExpose(e){warnRuntimeUsage("defineExpose")}function defineOptions(e){warnRuntimeUsage("defineOptions")}function defineSlots(){warnRuntimeUsage("defineSlots");return null}function defineModel(){warnRuntimeUsage("defineModel")}function withDefaults(e,t){warnRuntimeUsage("withDefaults");return null}function useSlots(){return getContext().slots}function useAttrs(){return getContext().attrs}function getContext(){const e=getCurrentInstance();e||warn$1("useContext() called without active instance.");return e.setupContext||(e.setupContext=createSetupContext(e))}function normalizePropsOrEmits(e){return r(e)?e.reduce(((e,t)=>(e[t]=null,e)),{}):e}function mergeDefaults(e,t){const n=normalizePropsOrEmits(e);for(const e in t){if(e.startsWith("__skip"))continue;let o=n[e];o?r(o)||isFunction(o)?o=n[e]={type:o,default:t[e]}:o.default=t[e]:o===null?o=n[e]={default:t[e]}:warn$1(`props default key "${e}" has no corresponding declaration.`);o&&t[`__skip_${e}`]&&(o.skipFactory=true)}return n}function mergeModels(e,t){return e&&t?r(e)&&r(t)?e.concat(t):n({},normalizePropsOrEmits(e),normalizePropsOrEmits(t)):e||t}function createPropsRestProxy(e,t){const n={};for(const o in e)t.includes(o)||Object.defineProperty(n,o,{enumerable:true,get:()=>e[o]});return n}function withAsyncContext(e){const t=getCurrentInstance();t||warn$1("withAsyncContext called without active current instance. This is likely a bug.");let n=e();unsetCurrentInstance();isPromise(n)&&(n=n.catch((e=>{setCurrentInstance(t);throw e})));return[n,()=>setCurrentInstance(t)]}function createDuplicateChecker(){const e=Object.create(null);return(t,n)=>{e[n]?warn$1(`${t} property "${n}" is already defined in ${e[n]}.`):e[n]=t}}let yt=true;function applyOptions(e){const t=resolveMergedOptions(e);const n=e.proxy;const o=e.ctx;yt=false;t.beforeCreate&&callHook$1(t.beforeCreate,e,"bc");const{data:s,computed:i,methods:a,watch:c,provide:l,inject:u,created:p,beforeMount:d,mounted:f,beforeUpdate:m,updated:g,activated:y,deactivated:v,beforeDestroy:b,beforeUnmount:C,destroyed:S,unmounted:x,render:w,renderTracked:E,renderTriggered:k,errorCaptured:_,serverPrefetch:T,expose:N,inheritAttrs:R,components:A,directives:$,filters:O}=t;const I=createDuplicateChecker();{const[t]=e.propsOptions;if(t)for(const e in t)I("Props",e)}u&&resolveInjections(u,o,I);if(a)for(const e in a){const t=a[e];if(isFunction(t)){Object.defineProperty(o,e,{value:t.bind(n),configurable:true,enumerable:true,writable:true});I("Methods",e)}else warn$1(`Method "${e}" has type "${typeof t}" in the component definition. Did you reference the function correctly?`)}if(s){isFunction(s)||warn$1("The data option must be a function. Plain object usage is no longer supported.");const t=s.call(n,n);isPromise(t)&&warn$1("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.");if(isObject(t)){e.data=reactive(t);for(const e in t){I("Data",e);isReservedPrefix(e[0])||Object.defineProperty(o,e,{configurable:true,enumerable:true,get:()=>t[e],set:NOOP})}}else warn$1("data() should return an object.")}yt=true;if(i)for(const e in i){const t=i[e];const r=isFunction(t)?t.bind(n,n):isFunction(t.get)?t.get.bind(n,n):NOOP;r===NOOP&&warn$1(`Computed property "${e}" has no getter.`);const s=!isFunction(t)&&isFunction(t.set)?t.set.bind(n):()=>{warn$1(`Write operation failed: computed property "${e}" is readonly.`)};const a=computed({get:r,set:s});Object.defineProperty(o,e,{enumerable:true,configurable:true,get:()=>a.value,set:e=>a.value=e});I("Computed",e)}if(c)for(const e in c)createWatcher(c[e],o,n,e);if(l){const e=isFunction(l)?l.call(n):l;Reflect.ownKeys(e).forEach((t=>{provide(t,e[t])}))}p&&callHook$1(p,e,"c");function registerLifecycleHook(e,t){r(t)?t.forEach((t=>e(t.bind(n)))):t&&e(t.bind(n))}registerLifecycleHook(st,d);registerLifecycleHook(it,f);registerLifecycleHook(at,m);registerLifecycleHook(ct,g);registerLifecycleHook(onActivated,y);registerLifecycleHook(onDeactivated,v);registerLifecycleHook(onErrorCaptured,_);registerLifecycleHook(ft,E);registerLifecycleHook(dt,k);registerLifecycleHook(lt,C);registerLifecycleHook(ut,x);registerLifecycleHook(pt,T);if(r(N))if(N.length){const t=e.exposed||(e.exposed={});N.forEach((e=>{Object.defineProperty(t,e,{get:()=>n[e],set:t=>n[e]=t})}))}else e.exposed||(e.exposed={});w&&e.render===NOOP&&(e.render=w);R!=null&&(e.inheritAttrs=R);A&&(e.components=A);$&&(e.directives=$)}function resolveInjections(e,t,n=NOOP){r(e)&&(e=normalizeInject(e));for(const o in e){const r=e[o];let s;s=isObject(r)?"default"in r?inject(r.from||o,r.default,true):inject(r.from||o):inject(r);isRef(s)?Object.defineProperty(t,o,{enumerable:true,configurable:true,get:()=>s.value,set:e=>s.value=e}):t[o]=s;n("Inject",o)}}function callHook$1(e,t,n){callWithAsyncErrorHandling(r(e)?e.map((e=>e.bind(t.proxy))):e.bind(t.proxy),t,n)}function createWatcher(e,t,n,o){const s=o.includes(".")?createPathGetter(n,o):()=>n[o];if(isString(e)){const n=t[e];isFunction(n)?watch(s,n):warn$1(`Invalid watch handler specified by key "${e}"`,n)}else if(isFunction(e))watch(s,e.bind(n));else if(isObject(e))if(r(e))e.forEach((e=>createWatcher(e,t,n,o)));else{const o=isFunction(e.handler)?e.handler.bind(n):t[e.handler];isFunction(o)?watch(s,o,e):warn$1(`Invalid watch handler specified by key "${e.handler}"`,o)}else warn$1(`Invalid watch option: "${o}"`,e)}function resolveMergedOptions(e){const t=e.type;const{mixins:n,extends:o}=t;const{mixins:r,optionsCache:s,config:{optionMergeStrategies:i}}=e.appContext;const a=s.get(t);let c;if(a)c=a;else if(r.length||n||o){c={};r.length&&r.forEach((e=>mergeOptions(c,e,i,true)));mergeOptions(c,t,i)}else c=t;isObject(t)&&s.set(t,c);return c}function mergeOptions(e,t,n,o=false){const{mixins:r,extends:s}=t;s&&mergeOptions(e,s,n,true);r&&r.forEach((t=>mergeOptions(e,t,n,true)));for(const r in t)if(o&&r==="expose")warn$1('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');else{const o=vt[r]||n&&n[r];e[r]=o?o(e[r],t[r]):t[r]}return e}const vt={data:mergeDataFn,props:mergeEmitsOrPropsOptions,emits:mergeEmitsOrPropsOptions,methods:mergeObjectOptions,computed:mergeObjectOptions,beforeCreate:mergeAsArray$1,created:mergeAsArray$1,beforeMount:mergeAsArray$1,mounted:mergeAsArray$1,beforeUpdate:mergeAsArray$1,updated:mergeAsArray$1,beforeDestroy:mergeAsArray$1,beforeUnmount:mergeAsArray$1,destroyed:mergeAsArray$1,unmounted:mergeAsArray$1,activated:mergeAsArray$1,deactivated:mergeAsArray$1,errorCaptured:mergeAsArray$1,serverPrefetch:mergeAsArray$1,components:mergeObjectOptions,directives:mergeObjectOptions,watch:mergeWatchOptions,provide:mergeDataFn,inject:mergeInject};function mergeDataFn(e,t){return t?e?function mergedDataFn(){return n(isFunction(e)?e.call(this,this):e,isFunction(t)?t.call(this,this):t)}:t:e}function mergeInject(e,t){return mergeObjectOptions(normalizeInject(e),normalizeInject(t))}function normalizeInject(e){if(r(e)){const t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function mergeAsArray$1(e,t){return e?[...new Set([].concat(e,t))]:t}function mergeObjectOptions(e,t){return e?n(Object.create(null),e,t):t}function mergeEmitsOrPropsOptions(e,t){return e?r(e)&&r(t)?[...new Set([...e,...t])]:n(Object.create(null),normalizePropsOrEmits(e),normalizePropsOrEmits(t!=null?t:{})):t}function mergeWatchOptions(e,t){if(!e)return t;if(!t)return e;const o=n(Object.create(null),e);for(const n in t)o[n]=mergeAsArray$1(e[n],t[n]);return o}function createAppContext(){return{app:null,config:{isNativeTag:NO,performance:false,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let bt=0;function createAppAPI(e,t){return function createApp(o,r=null){isFunction(o)||(o=n({},o));if(r!=null&&!isObject(r)){warn$1("root props passed to app.mount() must be an object.");r=null}const s=createAppContext();const i=new WeakSet;let a=false;const c=s.app={_uid:bt++,_component:o,_props:r,_container:null,_context:s,_instance:null,version:Jt,get config(){return s.config},set config(e){warn$1("app.config cannot be replaced. Modify individual options instead.")},use(e,...t){if(i.has(e))warn$1("Plugin has already been applied to target app.");else if(e&&isFunction(e.install)){i.add(e);e.install(c,...t)}else if(isFunction(e)){i.add(e);e(c,...t)}else warn$1('A plugin must either be a function or an object with an "install" function.');return c},mixin(e){s.mixins.includes(e)?warn$1("Mixin has already been applied to target app"+(e.name?`: ${e.name}`:"")):s.mixins.push(e);return c},component(e,t){validateComponentName(e,s.config);if(!t)return s.components[e];s.components[e]&&warn$1(`Component "${e}" has already been registered in target app.`);s.components[e]=t;return c},directive(e,t){validateDirectiveName(e);if(!t)return s.directives[e];s.directives[e]&&warn$1(`Directive "${e}" has already been registered in target app.`);s.directives[e]=t;return c},mount(n,i,l){if(!a){n.__vue_app__&&warn$1("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");const u=Ft(o,r);u.appContext=s;l===true?l="svg":l===false&&(l=void 0);s.reload=()=>{e(cloneVNode(u),n,l)};i&&t?t(u,n):e(u,n,l);a=true;c._container=n;n.__vue_app__=c;c._instance=u.component;devtoolsInitApp(c,Jt);return getExposeProxy(u.component)||u.component.proxy}warn$1("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`")},unmount(){if(a){e(null,c._container);c._instance=null;devtoolsUnmountApp(c);delete c._container.__vue_app__}else warn$1("Cannot unmount an app that is not mounted.")},provide(e,t){e in s.provides&&warn$1(`App already provides property with key "${String(e)}". It will be overwritten with the new value.`);s.provides[e]=t;return c},runWithContext(e){const t=Ct;Ct=c;try{return e()}finally{Ct=t}}};return c}}let Ct=null;function provide(e,t){if(Ht){let n=Ht.provides;const o=Ht.parent&&Ht.parent.provides;o===n&&(n=Ht.provides=Object.create(o));n[e]=t}else warn$1("provide() can only be used inside setup().")}function inject(e,t,n=false){const o=Ht||Le;if(o||Ct){const r=o?o.parent==null?o.vnode.appContext&&o.vnode.appContext.provides:o.parent.provides:Ct._context.provides;if(r&&e in r)return r[e];if(arguments.length>1)return n&&isFunction(t)?t.call(o&&o.proxy):t;warn$1(`injection "${String(e)}" not found.`)}else warn$1("inject() can only be used inside setup() or functional components.")}function hasInjectionContext(){return!!(Ht||Le||Ct)}const St=Object.create(null);const createInternalObject=()=>Object.create(St);const isInternalObject=e=>Object.getPrototypeOf(e)===St;function initProps(e,t,n,o=false){const r={};const s=createInternalObject();e.propsDefaults=Object.create(null);setFullProps(e,t,r,s);for(const t in e.propsOptions[0])t in r||(r[t]=void 0);validateProps(t||{},r,e);n?e.props=o?r:shallowReactive(r):e.type.props?e.props=r:e.props=s;e.attrs=s}function isInHmrContext(e){while(e){if(e.type.__hmrId)return true;e=e.parent}}function updateProps(e,t,n,o){const{props:r,attrs:s,vnode:{patchFlag:i}}=e;const a=toRaw(r);const[c]=e.propsOptions;let u=false;if(isInHmrContext(e)||!(o||i>0)||i&16){setFullProps(e,t,r,s)&&(u=true);let o;for(const s in a)t&&(hasOwn(t,s)||(o=p(s))!==s&&hasOwn(t,o))||(c?!n||n[s]===void 0&&n[o]===void 0||(r[s]=resolvePropValue(c,a,s,void 0,e,true)):delete r[s]);if(s!==a)for(const e in s)if(!t||!hasOwn(t,e)&&true){delete s[e];u=true}}else if(i&8){const n=e.vnode.dynamicProps;for(let o=0;o<n.length;o++){let i=n[o];if(isEmitListener(e.emitsOptions,i))continue;const p=t[i];if(c)if(hasOwn(s,i)){if(p!==s[i]){s[i]=p;u=true}}else{const t=l(i);r[t]=resolvePropValue(c,a,t,p,e,false)}else if(p!==s[i]){s[i]=p;u=true}}}u&&trigger(e.attrs,"set","");validateProps(t||{},r,e)}function setFullProps(t,n,o,r){const[s,a]=t.propsOptions;let c=false;let u;if(n)for(let e in n){if(i(e))continue;const p=n[e];let d;if(s&&hasOwn(s,d=l(e)))a&&a.includes(d)?(u||(u={}))[d]=p:o[d]=p;else if(!isEmitListener(t.emitsOptions,e)&&(!(e in r)||p!==r[e])){r[e]=p;c=true}}if(a){const n=toRaw(o);const r=u||e;for(let e=0;e<a.length;e++){const i=a[e];o[i]=resolvePropValue(s,n,i,r[i],t,!hasOwn(r,i))}}return c}function resolvePropValue(e,t,n,o,r,s){const i=e[n];if(i!=null){const e=hasOwn(i,"default");if(e&&o===void 0){const e=i.default;if(i.type!==Function&&!i.skipFactory&&isFunction(e)){const{propsDefaults:s}=r;if(n in s)o=s[n];else{const i=setCurrentInstance(r);o=s[n]=e.call(null,t);i()}}else o=e}i[0]&&(s&&!e?o=false:!i[1]||o!==""&&o!==p(n)||(o=true))}return o}function normalizePropsOptions(o,s,i=false){const a=s.propsCache;const c=a.get(o);if(c)return c;const u=o.props;const p={};const d=[];let f=false;if(!isFunction(o)){const extendProps=e=>{f=true;const[t,o]=normalizePropsOptions(e,s,true);n(p,t);o&&d.push(...o)};!i&&s.mixins.length&&s.mixins.forEach(extendProps);o.extends&&extendProps(o.extends);o.mixins&&o.mixins.forEach(extendProps)}if(!u&&!f){isObject(o)&&a.set(o,t);return t}if(r(u))for(let t=0;t<u.length;t++){isString(u[t])||warn$1("props must be strings when using array syntax.",u[t]);const n=l(u[t]);validatePropName(n)&&(p[n]=e)}else if(u){isObject(u)||warn$1("invalid props options",u);for(const e in u){const t=l(e);if(validatePropName(t)){const o=u[e];const s=p[t]=r(o)||isFunction(o)?{type:o}:n({},o);if(s){const e=getTypeIndex(Boolean,s.type);const n=getTypeIndex(String,s.type);s[0]=e>-1;s[1]=n<0||e<n;(e>-1||hasOwn(s,"default"))&&d.push(t)}}}}const m=[p,d];isObject(o)&&a.set(o,m);return m}function validatePropName(e){if(e[0]!=="$"&&!i(e))return true;warn$1(`Invalid prop name: "${e}" is a reserved property.`);return false}function getType(e){if(e===null)return"null";if(typeof e==="function")return e.name||"";if(typeof e==="object"){const t=e.constructor&&e.constructor.name;return t||""}return""}function isSameType(e,t){return getType(e)===getType(t)}function getTypeIndex(e,t){return r(t)?t.findIndex((t=>isSameType(t,e))):isFunction(t)&&isSameType(t,e)?0:-1}function validateProps(e,t,n){const o=toRaw(t);const r=n.propsOptions[0];for(const t in r){let n=r[t];n!=null&&validateProp(t,o[t],n,shallowReadonly(o),!hasOwn(e,t)&&!hasOwn(e,p(t)))}}function validateProp(e,t,n,o,s){const{type:i,required:a,validator:c,skipCheck:l}=n;if(a&&s)warn$1('Missing required prop: "'+e+'"');else if(t!=null||a){if(i!=null&&i!==true&&!l){let n=false;const o=r(i)?i:[i];const s=[];for(let e=0;e<o.length&&!n;e++){const{valid:r,expectedType:i}=assertType(t,o[e]);s.push(i||"");n=r}if(!n){warn$1(getInvalidTypeMessage(e,t,s));return}}c&&!c(t,o)&&warn$1('Invalid prop: custom validator check failed for prop "'+e+'".')}}const xt=makeMap("String,Number,Boolean,Function,Symbol,BigInt");function assertType(e,t){let n;const o=getType(t);if(xt(o)){const r=typeof e;n=r===o.toLowerCase();n||r!=="object"||(n=e instanceof t)}else n=o==="Object"?isObject(e):o==="Array"?r(e):o==="null"?e===null:e instanceof t;return{valid:n,expectedType:o}}function getInvalidTypeMessage(e,t,n){if(n.length===0)return`Prop type [] for prop "${e}" won't match anything. Did you mean to use type Array instead?`;let o=`Invalid prop: type check failed for prop "${e}". Expected ${n.map(d).join(" | ")}`;const r=n[0];const s=toRawType(t);const i=styleValue(t,r);const a=styleValue(t,s);n.length===1&&isExplicable(r)&&!isBoolean(r,s)&&(o+=` with value ${i}`);o+=`, got ${s} `;isExplicable(s)&&(o+=`with value ${a}.`);return o}function styleValue(e,t){return t==="String"?`"${e}"`:t==="Number"?`${Number(e)}`:`${e}`}function isExplicable(e){const t=["string","number","boolean"];return t.some((t=>e.toLowerCase()===t))}function isBoolean(...e){return e.some((e=>e.toLowerCase()==="boolean"))}const isInternalKey=e=>e[0]==="_"||e==="$stable";const normalizeSlotValue=e=>r(e)?e.map(normalizeVNode):[normalizeVNode(e)];const normalizeSlot=(e,t,n)=>{if(t._n)return t;const o=withCtx(((...o)=>{!Ht||n&&n.root!==Ht.root||warn$1(`Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);return normalizeSlotValue(t(...o))}),n);o._c=false;return o};const normalizeObjectSlots=(e,t,n)=>{const o=e._ctx;for(const n in e){if(isInternalKey(n))continue;const r=e[n];if(isFunction(r))t[n]=normalizeSlot(n,r,o);else if(r!=null){warn$1(`Non-function value encountered for slot "${n}". Prefer function slots for better performance.`);const e=normalizeSlotValue(r);t[n]=()=>e}}};const normalizeVNodeSlots=(e,t)=>{!isKeepAlive(e.vnode)&&true&&warn$1("Non-function value encountered for default slot. Prefer function slots for better performance.");const n=normalizeSlotValue(t);e.slots.default=()=>n};const initSlots=(e,t)=>{if(e.vnode.shapeFlag&32){const n=t._;if(n){e.slots=toRaw(t);def(e.slots,"_",n)}else normalizeObjectSlots(t,e.slots=createInternalObject())}else{e.slots=createInternalObject();t&&normalizeVNodeSlots(e,t)}};const updateSlots=(t,o,r)=>{const{vnode:s,slots:i}=t;let a=true;let c=e;if(s.shapeFlag&32){const e=o._;if(e)if(Ne){n(i,o);trigger(t,"set","$slots")}else if(r&&e===1)a=false;else{n(i,o);r||e!==1||delete i._}else{a=!o.$stable;normalizeObjectSlots(o,i)}c=o}else if(o){normalizeVNodeSlots(t,o);c={default:1}}if(a)for(const e in i)isInternalKey(e)||c[e]!=null||delete i[e]};function setRef(t,n,o,s,i=false){if(r(t)){t.forEach(((e,t)=>setRef(e,n&&(r(n)?n[t]:n),o,s,i)));return}if(isAsyncWrapper(s)&&!i)return;const a=s.shapeFlag&4?getExposeProxy(s.component)||s.component.proxy:s.el;const c=i?null:a;const{i:l,r:u}=t;if(!l){warn$1("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");return}const p=n&&n.r;const d=l.refs===e?l.refs={}:l.refs;const f=l.setupState;if(p!=null&&p!==u)if(isString(p)){d[p]=null;hasOwn(f,p)&&(f[p]=null)}else isRef(p)&&(p.value=null);if(isFunction(u))callWithErrorHandling(u,l,12,[c,d]);else{const e=isString(u);const n=isRef(u);if(e||n){const doSet=()=>{if(t.f){const n=e?hasOwn(f,u)?f[u]:d[u]:u.value;if(i)r(n)&&remove(n,a);else if(r(n))n.includes(a)||n.push(a);else if(e){d[u]=[a];hasOwn(f,u)&&(f[u]=d[u])}else{u.value=[a];t.k&&(d[t.k]=u.value)}}else if(e){d[u]=c;hasOwn(f,u)&&(f[u]=c)}else if(n){u.value=c;t.k&&(d[t.k]=c)}else warn$1("Invalid template ref type:",u,`(${typeof u})`)};if(c){doSet.id=-1;_t(doSet,o)}else doSet()}else warn$1("Invalid template ref type:",u,`(${typeof u})`)}}let wt=false;const isSVGContainer=e=>e.namespaceURI.includes("svg")&&e.tagName!=="foreignObject";const isMathMLContainer=e=>e.namespaceURI.includes("MathML");const getContainerType=e=>isSVGContainer(e)?"svg":isMathMLContainer(e)?"mathml":void 0;const isComment=e=>e.nodeType===8;function createHydrationFunctions(e){const{mt:t,p:n,o:{patchProp:o,createText:r,nextSibling:s,parentNode:a,remove:c,insert:l,createComment:u}}=e;const hydrate=(e,t)=>{if(t.hasChildNodes()){wt=false;hydrateNode(t.firstChild,e,null,null,null);flushPostFlushCbs();t._vnode=e;wt&&true&&console.error("Hydration completed but contains mismatches.")}else{warn$1("Attempting to hydrate existing markup but container is empty. Performing full mount instead.");n(null,e,t);flushPostFlushCbs();t._vnode=e}};const hydrateNode=(n,o,i,c,u,p=false)=>{p=p||!!o.dynamicChildren;const d=isComment(n)&&n.data==="[";const onMismatch=()=>handleMismatch(n,o,i,c,u,d);const{type:f,ref:m,shapeFlag:g,patchFlag:y}=o;let v=n.nodeType;o.el=n;"__vnode"in n||Object.defineProperty(n,"__vnode",{value:o,enumerable:false});"__vueParentComponent"in n||Object.defineProperty(n,"__vueParentComponent",{value:i,enumerable:false});if(y===-2){p=false;o.dynamicChildren=null}let b=null;switch(f){case At:if(v!==3)if(o.children===""){l(o.el=r(""),a(n),n);b=n}else b=onMismatch();else{if(n.data!==o.children){wt=true;warn$1("Hydration text mismatch in",n.parentNode,`\n  - rendered on server: ${JSON.stringify(n.data)}\n  - expected on client: ${JSON.stringify(o.children)}`);n.data=o.children}b=s(n)}break;case $t:if(isTemplateNode(n)){b=s(n);replaceNode(o.el=n.content.firstChild,n,i)}else b=v!==8||d?onMismatch():s(n);break;case Ot:if(d){n=s(n);v=n.nodeType}if(v===1||v===3){b=n;const e=!o.children.length;for(let t=0;t<o.staticCount;t++){e&&(o.children+=b.nodeType===1?b.outerHTML:b.data);t===o.staticCount-1&&(o.anchor=b);b=s(b)}return d?s(b):b}onMismatch();break;case Rt:b=d?hydrateFragment(n,o,i,c,u,p):onMismatch();break;default:if(g&1)b=v===1&&o.type.toLowerCase()===n.tagName.toLowerCase()||isTemplateNode(n)?hydrateElement(n,o,i,c,u,p):onMismatch();else if(g&6){o.slotScopeIds=u;const e=a(n);b=d?locateClosingAnchor(n):isComment(n)&&n.data==="teleport start"?locateClosingAnchor(n,n.data,"teleport end"):s(n);t(o,e,null,i,c,getContainerType(e),p);if(isAsyncWrapper(o)){let t;if(d){t=Ft(Rt);t.anchor=b?b.previousSibling:e.lastChild}else t=n.nodeType===3?createTextVNode(""):Ft("div");t.el=n;o.component.subTree=t}}else g&64?b=v!==8?onMismatch():o.type.hydrate(n,o,i,c,u,p,e,hydrateChildren):g&128?b=o.type.hydrate(n,o,i,c,getContainerType(a(n)),u,p,e,hydrateNode):warn$1("Invalid HostVNode type:",f,`(${typeof f})`)}m!=null&&setRef(m,null,c,o);return b};const hydrateElement=(e,t,n,r,s,a)=>{a=a||!!t.dynamicChildren;const{type:l,props:u,patchFlag:p,shapeFlag:d,dirs:f,transition:m}=t;const g=l==="input"||l==="option";{f&&invokeDirectiveHook(t,null,n,"created");let l=false;if(isTemplateNode(e)){l=needTransition(r,m)&&n&&n.vnode.props&&n.vnode.props.appear;const o=e.content.firstChild;l&&m.beforeEnter(o);replaceNode(o,e,n);t.el=e=o}if(d&16&&!(u&&(u.innerHTML||u.textContent))){let o=hydrateChildren(e.firstChild,t,e,n,r,s,a);let i=false;while(o){wt=true;if(!i){warn$1("Hydration children mismatch on",e,"\nServer rendered element contains more child nodes than client vdom.");i=true}const t=o;o=o.nextSibling;c(t)}}else if(d&8&&e.textContent!==t.children){wt=true;warn$1("Hydration text content mismatch on",e,`\n  - rendered on server: ${e.textContent}\n  - expected on client: ${t.children}`);e.textContent=t.children}if(u)for(const r in u){propHasMismatch(e,r,u[r],t,n)&&(wt=true);(g&&(r.endsWith("value")||r==="indeterminate")||isOn(r)&&!i(r)||r[0]===".")&&o(e,r,null,u[r],void 0,void 0,n)}let p;(p=u&&u.onVnodeBeforeMount)&&invokeVNodeHook(p,n,t);f&&invokeDirectiveHook(t,null,n,"beforeMount");((p=u&&u.onVnodeMounted)||f||l)&&queueEffectWithSuspense((()=>{p&&invokeVNodeHook(p,n,t);l&&m.enter(e);f&&invokeDirectiveHook(t,null,n,"mounted")}),r)}return e.nextSibling};const hydrateChildren=(e,t,o,r,s,i,a)=>{a=a||!!t.dynamicChildren;const c=t.children;const l=c.length;let u=false;for(let t=0;t<l;t++){const l=a?c[t]:c[t]=normalizeVNode(c[t]);if(e)e=hydrateNode(e,l,r,s,i,a);else{if(l.type===At&&!l.children)continue;wt=true;if(!u){warn$1("Hydration children mismatch on",o,"\nServer rendered element contains fewer child nodes than client vdom.");u=true}n(null,l,o,null,r,s,getContainerType(o),i)}}return e};const hydrateFragment=(e,t,n,o,r,i)=>{const{slotScopeIds:c}=t;c&&(r=r?r.concat(c):c);const p=a(e);const d=hydrateChildren(s(e),t,p,n,o,r,i);if(d&&isComment(d)&&d.data==="]")return s(t.anchor=d);wt=true;l(t.anchor=u("]"),p,d);return d};const handleMismatch=(e,t,o,r,i,l)=>{wt=true;warn$1("Hydration node mismatch:\n- rendered on server:",e,e.nodeType===3?"(text)":isComment(e)&&e.data==="["?"(start of fragment)":"","\n- expected on client:",t.type);t.el=null;if(l){const t=locateClosingAnchor(e);while(true){const n=s(e);if(!n||n===t)break;c(n)}}const u=s(e);const p=a(e);c(e);n(null,t,p,u,o,r,getContainerType(p),i);return u};const locateClosingAnchor=(e,t="[",n="]")=>{let o=0;while(e){e=s(e);if(e&&isComment(e)){e.data===t&&o++;if(e.data===n){if(o===0)return s(e);o--}}}return e};const replaceNode=(e,t,n)=>{const o=t.parentNode;o&&o.replaceChild(e,t);let r=n;while(r){r.vnode.el===t&&(r.vnode.el=r.subTree.el=e);r=r.parent}};const isTemplateNode=e=>e.nodeType===1&&e.tagName.toLowerCase()==="template";return[hydrate,hydrateNode]}function propHasMismatch(e,t,n,o,r){var s;let i;let a;let c;let l;if(t==="class"){c=e.getAttribute("class");l=normalizeClass(n);isSetEqual(toClassSet(c||""),toClassSet(l))||(i=a="class")}else if(t==="style"){c=e.getAttribute("style");l=isString(n)?n:stringifyStyle(normalizeStyle(n));const t=toStyleMap(c);const u=toStyleMap(l);if(o.dirs)for(const{dir:e,value:t}of o.dirs)e.name!=="show"||t||u.set("display","none");const p=r==null?void 0:r.subTree;if(o===p||(p==null?void 0:p.type)===Rt&&p.children.includes(o)){const e=(s=r==null?void 0:r.getCssVars)==null?void 0:s.call(r);for(const t in e)u.set(`--${t}`,String(e[t]))}isMapEqual(t,u)||(i=a="style")}else if(e instanceof SVGElement&&M(t)||e instanceof HTMLElement&&(P(t)||V(t))){if(P(t)){c=e.hasAttribute(t);l=includeBooleanAttr(n)}else if(n==null){c=e.hasAttribute(t);l=false}else{c=e.hasAttribute(t)?e.getAttribute(t):t==="value"&&e.tagName==="TEXTAREA"&&e.value;l=!!isRenderableAttrValue(n)&&String(n)}if(c!==l){i="attribute";a=t}}if(i){const format=e=>e===false?"(not rendered)":`${a}="${e}"`;const t=`Hydration ${i} mismatch on`;const n=`\n  - rendered on server: ${format(c)}\n  - expected on client: ${format(l)}\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.`;warn$1(t,e,n);return true}return false}function toClassSet(e){return new Set(e.trim().split(/\s+/))}function isSetEqual(e,t){if(e.size!==t.size)return false;for(const n of e)if(!t.has(n))return false;return true}function toStyleMap(e){const t=new Map;for(const n of e.split(";")){let[e,o]=n.split(":");e=e==null?void 0:e.trim();o=o==null?void 0:o.trim();e&&o&&t.set(e,o)}return t}function isMapEqual(e,t){if(e.size!==t.size)return false;for(const[n,o]of e)if(o!==t.get(n))return false;return true}let Et;let kt;function startMeasure(e,t){e.appContext.config.performance&&isSupported()&&kt.mark(`vue-${t}-${e.uid}`);Fe(e,t,isSupported()?kt.now():Date.now())}function endMeasure(e,t){if(e.appContext.config.performance&&isSupported()){const n=`vue-${t}-${e.uid}`;const o=n+":end";kt.mark(o);kt.measure(`<${formatComponentName(e,e.type)}> ${t}`,n,o);kt.clearMarks(n);kt.clearMarks(o)}De(e,t,isSupported()?kt.now():Date.now())}function isSupported(){if(Et!==void 0)return Et;if(typeof window!=="undefined"&&window.performance){Et=true;kt=window.performance}else Et=false;return Et}const _t=queueEffectWithSuspense;function createRenderer(e){return baseCreateRenderer(e)}function createHydrationRenderer(e){return baseCreateRenderer(e,createHydrationFunctions)}function baseCreateRenderer(n,o){const r=getGlobalThis();r.__VUE__=true;setDevtoolsHook$1(r.__VUE_DEVTOOLS_GLOBAL_HOOK__,r);const{insert:s,remove:a,patchProp:c,createElement:l,createText:u,createComment:p,setText:d,setElementText:f,parentNode:m,nextSibling:g,setScopeId:y=NOOP,insertStaticContent:v}=n;const patch=(e,t,n,o=null,r=null,s=null,i=void 0,a=null,c=!Ne&&!!t.dynamicChildren)=>{if(e===t)return;if(e&&!isSameVNodeType(e,t)){o=getNextHostNode(e);unmount(e,r,s,true);e=null}if(t.patchFlag===-2){c=false;t.dynamicChildren=null}const{type:l,ref:u,shapeFlag:p}=t;switch(l){case At:processText(e,t,n,o);break;case $t:processCommentNode(e,t,n,o);break;case Ot:e==null?mountStaticNode(t,n,o,i):patchStaticNode(e,t,n,i);break;case Rt:processFragment(e,t,n,o,r,s,i,a,c);break;default:p&1?processElement(e,t,n,o,r,s,i,a,c):p&6?processComponent(e,t,n,o,r,s,i,a,c):p&64||p&128?l.process(e,t,n,o,r,s,i,a,c,C):warn$1("Invalid VNode type:",l,`(${typeof l})`)}u!=null&&r&&setRef(u,e&&e.ref,s,t||e,!t)};const processText=(e,t,n,o)=>{if(e==null)s(t.el=u(t.children),n,o);else{const n=t.el=e.el;t.children!==e.children&&d(n,t.children)}};const processCommentNode=(e,t,n,o)=>{e==null?s(t.el=p(t.children||""),n,o):t.el=e.el};const mountStaticNode=(e,t,n,o)=>{[e.el,e.anchor]=v(e.children,t,n,o,e.el,e.anchor)};const patchStaticNode=(e,t,n,o)=>{if(t.children!==e.children){const r=g(e.anchor);removeStaticNode(e);[t.el,t.anchor]=v(t.children,n,r,o)}else{t.el=e.el;t.anchor=e.anchor}};const moveStaticNode=({el:e,anchor:t},n,o)=>{let r;while(e&&e!==t){r=g(e);s(e,n,o);e=r}s(t,n,o)};const removeStaticNode=({el:e,anchor:t})=>{let n;while(e&&e!==t){n=g(e);a(e);e=n}a(t)};const processElement=(e,t,n,o,r,s,i,a,c)=>{t.type==="svg"?i="svg":t.type==="math"&&(i="mathml");e==null?mountElement(t,n,o,r,s,i,a,c):patchElement(e,t,r,s,i,a,c)};const mountElement=(e,t,n,o,r,a,u,p)=>{let d;let m;const{props:g,shapeFlag:y,transition:v,dirs:b}=e;d=e.el=l(e.type,a,g&&g.is,g);y&8?f(d,e.children):y&16&&mountChildren(e.children,d,null,o,r,resolveChildrenNamespace(e,a),u,p);b&&invokeDirectiveHook(e,null,o,"created");setScopeId(d,e,e.scopeId,u,o);if(g){for(const t in g)t==="value"||i(t)||c(d,t,null,g[t],a,e.children,o,r,unmountChildren);"value"in g&&c(d,"value",null,g.value,a);(m=g.onVnodeBeforeMount)&&invokeVNodeHook(m,o,e)}Object.defineProperty(d,"__vnode",{value:e,enumerable:false});Object.defineProperty(d,"__vueParentComponent",{value:o,enumerable:false});b&&invokeDirectiveHook(e,null,o,"beforeMount");const C=needTransition(r,v);C&&v.beforeEnter(d);s(d,t,n);((m=g&&g.onVnodeMounted)||C||b)&&_t((()=>{m&&invokeVNodeHook(m,o,e);C&&v.enter(d);b&&invokeDirectiveHook(e,null,o,"mounted")}),r)};const setScopeId=(e,t,n,o,r)=>{n&&y(e,n);if(o)for(let t=0;t<o.length;t++)y(e,o[t]);if(r){let n=r.subTree;n.patchFlag>0&&n.patchFlag&2048&&(n=filterSingleRoot(n.children)||n);if(t===n){const t=r.vnode;setScopeId(e,t,t.scopeId,t.slotScopeIds,r.parent)}}};const mountChildren=(e,t,n,o,r,s,i,a,c=0)=>{for(let l=c;l<e.length;l++){const c=e[l]=a?cloneIfMounted(e[l]):normalizeVNode(e[l]);patch(null,c,t,n,o,r,s,i,a)}};const patchElement=(t,n,o,r,s,i,a)=>{const l=n.el=t.el;let{patchFlag:u,dynamicChildren:p,dirs:d}=n;u|=t.patchFlag&16;const m=t.props||e;const g=n.props||e;let y;o&&toggleRecurse(o,false);(y=g.onVnodeBeforeUpdate)&&invokeVNodeHook(y,o,n,t);d&&invokeDirectiveHook(n,t,o,"beforeUpdate");o&&toggleRecurse(o,true);if(Ne){u=0;a=false;p=null}if(p){patchBlockChildren(t.dynamicChildren,p,l,o,r,resolveChildrenNamespace(n,s),i);traverseStaticChildren(t,n)}else a||patchChildren(t,n,l,null,o,r,resolveChildrenNamespace(n,s),i,false);if(u>0){if(u&16)patchProps(l,n,m,g,o,r,s);else{u&2&&m.class!==g.class&&c(l,"class",null,g.class,s);u&4&&c(l,"style",m.style,g.style,s);if(u&8){const e=n.dynamicProps;for(let n=0;n<e.length;n++){const i=e[n];const a=m[i];const u=g[i];u===a&&i!=="value"||c(l,i,a,u,s,t.children,o,r,unmountChildren)}}}u&1&&t.children!==n.children&&f(l,n.children)}else a||p!=null||patchProps(l,n,m,g,o,r,s);((y=g.onVnodeUpdated)||d)&&_t((()=>{y&&invokeVNodeHook(y,o,n,t);d&&invokeDirectiveHook(n,t,o,"updated")}),r)};const patchBlockChildren=(e,t,n,o,r,s,i)=>{for(let a=0;a<t.length;a++){const c=e[a];const l=t[a];const u=c.el&&(c.type===Rt||!isSameVNodeType(c,l)||c.shapeFlag&70)?m(c.el):n;patch(c,l,u,null,o,r,s,i,true)}};const patchProps=(t,n,o,r,s,a,l)=>{if(o!==r){if(o!==e)for(const e in o)i(e)||e in r||c(t,e,o[e],null,l,n.children,s,a,unmountChildren);for(const e in r){if(i(e))continue;const u=r[e];const p=o[e];u!==p&&e!=="value"&&c(t,e,p,u,l,n.children,s,a,unmountChildren)}"value"in r&&c(t,"value",o.value,r.value,l)}};const processFragment=(e,t,n,o,r,i,a,c,l)=>{const p=t.el=e?e.el:u("");const d=t.anchor=e?e.anchor:u("");let{patchFlag:f,dynamicChildren:m,slotScopeIds:g}=t;if(Ne||f&2048){f=0;l=false;m=null}g&&(c=c?c.concat(g):g);if(e==null){s(p,n,o);s(d,n,o);mountChildren(t.children||[],n,d,r,i,a,c,l)}else if(f>0&&f&64&&m&&e.dynamicChildren){patchBlockChildren(e.dynamicChildren,m,n,r,i,a,c);traverseStaticChildren(e,t)}else patchChildren(e,t,n,d,r,i,a,c,l)};const processComponent=(e,t,n,o,r,s,i,a,c)=>{t.slotScopeIds=a;e==null?t.shapeFlag&512?r.ctx.activate(t,n,o,i,c):mountComponent(t,n,o,r,s,i,c):updateComponent(e,t,c)};const mountComponent=(e,t,n,o,r,s,i)=>{const a=e.component=createComponentInstance(e,o,r);a.type.__hmrId&&registerHMR(a);pushWarningContext(e);startMeasure(a,"mount");isKeepAlive(e)&&(a.ctx.renderer=C);startMeasure(a,"init");setupComponent(a);endMeasure(a,"init");if(a.asyncDep){r&&r.registerDep(a,setupRenderEffect);if(!e.el){const e=a.subTree=Ft($t);processCommentNode(null,e,t,n)}}else setupRenderEffect(a,e,t,n,r,s,i);popWarningContext();endMeasure(a,"mount")};const updateComponent=(e,t,n)=>{const o=t.component=e.component;if(shouldUpdateComponent(e,t,n)){if(o.asyncDep&&!o.asyncResolved){pushWarningContext(t);updateComponentPreRender(o,t,n);popWarningContext();return}o.next=t;invalidateJob(o.update);o.effect.dirty=true;o.update()}else{t.el=e.el;o.vnode=t}};const setupRenderEffect=(e,t,n,o,r,s,i)=>{const componentUpdateFn=()=>{if(e.isMounted){let{next:t,bu:n,u:o,parent:a,vnode:c}=e;{const n=locateNonHydratedAsyncRoot(e);if(n){if(t){t.el=c.el;updateComponentPreRender(e,t,i)}n.asyncDep.then((()=>{e.isUnmounted||componentUpdateFn()}));return}}let l=t;let u;pushWarningContext(t||e.vnode);toggleRecurse(e,false);if(t){t.el=c.el;updateComponentPreRender(e,t,i)}else t=c;n&&invokeArrayFns(n);(u=t.props&&t.props.onVnodeBeforeUpdate)&&invokeVNodeHook(u,a,t,c);toggleRecurse(e,true);startMeasure(e,"render");const p=renderComponentRoot(e);endMeasure(e,"render");const d=e.subTree;e.subTree=p;startMeasure(e,"patch");patch(d,p,m(d.el),getNextHostNode(d),e,r,s);endMeasure(e,"patch");t.el=p.el;l===null&&updateHOCHostEl(e,p.el);o&&_t(o,r);(u=t.props&&t.props.onVnodeUpdated)&&_t((()=>invokeVNodeHook(u,a,t,c)),r);Ve(e);popWarningContext()}else{let i;const{el:a,props:c}=t;const{bm:l,m:u,parent:p}=e;const d=isAsyncWrapper(t);toggleRecurse(e,false);l&&invokeArrayFns(l);!d&&(i=c&&c.onVnodeBeforeMount)&&invokeVNodeHook(i,p,t);toggleRecurse(e,true);if(a&&x){const hydrateSubTree=()=>{startMeasure(e,"render");e.subTree=renderComponentRoot(e);endMeasure(e,"render");startMeasure(e,"hydrate");x(a,e.subTree,e,r,null);endMeasure(e,"hydrate")};d?t.type.__asyncLoader().then((()=>!e.isUnmounted&&hydrateSubTree())):hydrateSubTree()}else{startMeasure(e,"render");const i=e.subTree=renderComponentRoot(e);endMeasure(e,"render");startMeasure(e,"patch");patch(null,i,n,o,e,r,s);endMeasure(e,"patch");t.el=i.el}u&&_t(u,r);if(!d&&(i=c&&c.onVnodeMounted)){const e=t;_t((()=>invokeVNodeHook(i,p,e)),r)}(t.shapeFlag&256||p&&isAsyncWrapper(p.vnode)&&p.vnode.shapeFlag&256)&&e.a&&_t(e.a,r);e.isMounted=true;Pe(e);t=n=o=null}};const a=e.effect=new ReactiveEffect(componentUpdateFn,NOOP,(()=>queueJob(c)),e.scope);const c=e.update=()=>{a.dirty&&a.run()};c.id=e.uid;toggleRecurse(e,true);a.onTrack=e.rtc?t=>invokeArrayFns(e.rtc,t):void 0;a.onTrigger=e.rtg?t=>invokeArrayFns(e.rtg,t):void 0;c.ownerInstance=e;c()};const updateComponentPreRender=(e,t,n)=>{t.component=e;const o=e.vnode.props;e.vnode=t;e.next=null;updateProps(e,t.props,o,n);updateSlots(e,t.children,n);pauseTracking();flushPreFlushCbs(e);resetTracking()};const patchChildren=(e,t,n,o,r,s,i,a,c=false)=>{const l=e&&e.children;const u=e?e.shapeFlag:0;const p=t.children;const{patchFlag:d,shapeFlag:m}=t;if(d>0){if(d&128){patchKeyedChildren(l,p,n,o,r,s,i,a,c);return}if(d&256){patchUnkeyedChildren(l,p,n,o,r,s,i,a,c);return}}if(m&8){u&16&&unmountChildren(l,r,s);p!==l&&f(n,p)}else if(u&16)m&16?patchKeyedChildren(l,p,n,o,r,s,i,a,c):unmountChildren(l,r,s,true);else{u&8&&f(n,"");m&16&&mountChildren(p,n,o,r,s,i,a,c)}};const patchUnkeyedChildren=(e,n,o,r,s,i,a,c,l)=>{e=e||t;n=n||t;const u=e.length;const p=n.length;const d=Math.min(u,p);let f;for(f=0;f<d;f++){const t=n[f]=l?cloneIfMounted(n[f]):normalizeVNode(n[f]);patch(e[f],t,o,null,s,i,a,c,l)}u>p?unmountChildren(e,s,i,true,false,d):mountChildren(n,o,r,s,i,a,c,l,d)};const patchKeyedChildren=(e,n,o,r,s,i,a,c,l)=>{let u=0;const p=n.length;let d=e.length-1;let f=p-1;while(u<=d&&u<=f){const t=e[u];const r=n[u]=l?cloneIfMounted(n[u]):normalizeVNode(n[u]);if(!isSameVNodeType(t,r))break;patch(t,r,o,null,s,i,a,c,l);u++}while(u<=d&&u<=f){const t=e[d];const r=n[f]=l?cloneIfMounted(n[f]):normalizeVNode(n[f]);if(!isSameVNodeType(t,r))break;patch(t,r,o,null,s,i,a,c,l);d--;f--}if(u>d){if(u<=f){const e=f+1;const t=e<p?n[e].el:r;while(u<=f){patch(null,n[u]=l?cloneIfMounted(n[u]):normalizeVNode(n[u]),o,t,s,i,a,c,l);u++}}}else if(u>f)while(u<=d){unmount(e[u],s,i,true);u++}else{const m=u;const g=u;const y=new Map;for(u=g;u<=f;u++){const e=n[u]=l?cloneIfMounted(n[u]):normalizeVNode(n[u]);if(e.key!=null){y.has(e.key)&&warn$1("Duplicate keys found during update:",JSON.stringify(e.key),"Make sure keys are unique.");y.set(e.key,u)}}let v;let b=0;const C=f-g+1;let S=false;let x=0;const w=new Array(C);for(u=0;u<C;u++)w[u]=0;for(u=m;u<=d;u++){const t=e[u];if(b>=C){unmount(t,s,i,true);continue}let r;if(t.key!=null)r=y.get(t.key);else for(v=g;v<=f;v++)if(w[v-g]===0&&isSameVNodeType(t,n[v])){r=v;break}if(r===void 0)unmount(t,s,i,true);else{w[r-g]=u+1;r>=x?x=r:S=true;patch(t,n[r],o,null,s,i,a,c,l);b++}}const E=S?getSequence(w):t;v=E.length-1;for(u=C-1;u>=0;u--){const e=g+u;const t=n[e];const d=e+1<p?n[e+1].el:r;w[u]===0?patch(null,t,o,d,s,i,a,c,l):S&&(v<0||u!==E[v]?move(t,o,d,2):v--)}}};const move=(e,t,n,o,r=null)=>{const{el:i,type:a,transition:c,children:l,shapeFlag:u}=e;if(u&6){move(e.component.subTree,t,n,o);return}if(u&128){e.suspense.move(t,n,o);return}if(u&64){a.move(e,t,n,C);return}if(a===Rt){s(i,t,n);for(let e=0;e<l.length;e++)move(l[e],t,n,o);s(e.anchor,t,n);return}if(a===Ot){moveStaticNode(e,t,n);return}const p=o!==2&&u&1&&c;if(p)if(o===0){c.beforeEnter(i);s(i,t,n);_t((()=>c.enter(i)),r)}else{const{leave:e,delayLeave:o,afterLeave:r}=c;const remove2=()=>s(i,t,n);const performLeave=()=>{e(i,(()=>{remove2();r&&r()}))};o?o(i,remove2,performLeave):performLeave()}else s(i,t,n)};const unmount=(e,t,n,o=false,r=false)=>{const{type:s,props:i,ref:a,children:c,dynamicChildren:l,shapeFlag:u,patchFlag:p,dirs:d}=e;a!=null&&setRef(a,null,n,e,true);if(u&256){t.ctx.deactivate(e);return}const f=u&1&&d;const m=!isAsyncWrapper(e);let g;m&&(g=i&&i.onVnodeBeforeUnmount)&&invokeVNodeHook(g,t,e);if(u&6)unmountComponent(e.component,n,o);else{if(u&128){e.suspense.unmount(n,o);return}f&&invokeDirectiveHook(e,null,t,"beforeUnmount");u&64?e.type.remove(e,t,n,r,C,o):l&&(s!==Rt||p>0&&p&64)?unmountChildren(l,t,n,false,true):(s===Rt&&p&384||!r&&u&16)&&unmountChildren(c,t,n);o&&remove(e)}(m&&(g=i&&i.onVnodeUnmounted)||f)&&_t((()=>{g&&invokeVNodeHook(g,t,e);f&&invokeDirectiveHook(e,null,t,"unmounted")}),n)};const remove=e=>{const{type:t,el:n,anchor:o,transition:r}=e;if(t===Rt){e.patchFlag>0&&e.patchFlag&2048&&r&&!r.persisted?e.children.forEach((e=>{e.type===$t?a(e.el):remove(e)})):removeFragment(n,o);return}if(t===Ot){removeStaticNode(e);return}const performRemove=()=>{a(n);r&&!r.persisted&&r.afterLeave&&r.afterLeave()};if(e.shapeFlag&1&&r&&!r.persisted){const{leave:t,delayLeave:o}=r;const performLeave=()=>t(n,performRemove);o?o(e.el,performRemove,performLeave):performLeave()}else performRemove()};const removeFragment=(e,t)=>{let n;while(e!==t){n=g(e);a(e);e=n}a(t)};const unmountComponent=(e,t,n)=>{e.type.__hmrId&&unregisterHMR(e);const{bum:o,scope:r,update:s,subTree:i,um:a}=e;o&&invokeArrayFns(o);r.stop();if(s){s.active=false;unmount(i,e,t,n)}a&&_t(a,t);_t((()=>{e.isUnmounted=true}),t);if(t&&t.pendingBranch&&!t.isUnmounted&&e.asyncDep&&!e.asyncResolved&&e.suspenseId===t.pendingId){t.deps--;t.deps===0&&t.resolve()}devtoolsComponentRemoved(e)};const unmountChildren=(e,t,n,o=false,r=false,s=0)=>{for(let i=s;i<e.length;i++)unmount(e[i],t,n,o,r)};const getNextHostNode=e=>e.shapeFlag&6?getNextHostNode(e.component.subTree):e.shapeFlag&128?e.suspense.next():g(e.anchor||e.el);let b=false;const render=(e,t,n)=>{e==null?t._vnode&&unmount(t._vnode,null,null,true):patch(t._vnode||null,e,t,null,null,null,n);if(!b){b=true;flushPreFlushCbs();flushPostFlushCbs();b=false}t._vnode=e};const C={p:patch,um:unmount,m:move,r:remove,mt:mountComponent,mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,n:getNextHostNode,o:n};let S;let x;o&&([S,x]=o(C));return{render:render,hydrate:S,createApp:createAppAPI(render,S)}}function resolveChildrenNamespace({type:e,props:t},n){return n==="svg"&&e==="foreignObject"||n==="mathml"&&e==="annotation-xml"&&t&&t.encoding&&t.encoding.includes("html")?void 0:n}function toggleRecurse({effect:e,update:t},n){e.allowRecurse=t.allowRecurse=n}function needTransition(e,t){return(!e||e&&!e.pendingBranch)&&t&&!t.persisted}function traverseStaticChildren(e,t,n=false){const o=e.children;const s=t.children;if(r(o)&&r(s))for(let e=0;e<o.length;e++){const t=o[e];let r=s[e];if(r.shapeFlag&1&&!r.dynamicChildren){if(r.patchFlag<=0||r.patchFlag===32){r=s[e]=cloneIfMounted(s[e]);r.el=t.el}n||traverseStaticChildren(t,r)}r.type===At&&(r.el=t.el);r.type!==$t||r.el||(r.el=t.el)}}function getSequence(e){const t=e.slice();const n=[0];let o,r,s,i,a;const c=e.length;for(o=0;o<c;o++){const c=e[o];if(c!==0){r=n[n.length-1];if(e[r]<c){t[o]=r;n.push(o);continue}s=0;i=n.length-1;while(s<i){a=s+i>>1;e[n[a]]<c?s=a+1:i=a}if(c<e[n[s]]){s>0&&(t[o]=n[s-1]);n[s]=o}}}s=n.length;i=n[s-1];while(s-- >0){n[s]=i;i=t[i]}return n}function locateNonHydratedAsyncRoot(e){const t=e.subTree.component;if(t)return t.asyncDep&&!t.asyncResolved?t:locateNonHydratedAsyncRoot(t)}const isTeleport=e=>e.__isTeleport;const isTeleportDisabled=e=>e&&(e.disabled||e.disabled==="");const isTargetSVG=e=>typeof SVGElement!=="undefined"&&e instanceof SVGElement;const isTargetMathML=e=>typeof MathMLElement==="function"&&e instanceof MathMLElement;const resolveTarget=(e,t)=>{const n=e&&e.to;if(isString(n)){if(t){const e=t(n);e||warn$1(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);return e}warn$1("Current renderer does not support string target for Teleports. (missing querySelector renderer option)");return null}n||isTeleportDisabled(e)||warn$1(`Invalid Teleport target: ${n}`);return n};const Tt={name:"Teleport",__isTeleport:true,process(e,t,n,o,r,s,i,a,c,l){const{mc:u,pc:p,pbc:d,o:{insert:f,querySelector:m,createText:g,createComment:y}}=l;const v=isTeleportDisabled(t.props);let{shapeFlag:b,children:C,dynamicChildren:S}=t;if(Ne){c=false;S=null}if(e==null){const e=t.el=y("teleport start");const l=t.anchor=y("teleport end");f(e,n,o);f(l,n,o);const p=t.target=resolveTarget(t.props,m);const d=t.targetAnchor=g("");if(p){f(d,p);i==="svg"||isTargetSVG(p)?i="svg":(i==="mathml"||isTargetMathML(p))&&(i="mathml")}else v||warn$1("Invalid Teleport target on mount:",p,`(${typeof p})`);const mount=(e,t)=>{b&16&&u(C,e,t,r,s,i,a,c)};v?mount(n,l):p&&mount(p,d)}else{t.el=e.el;const o=t.anchor=e.anchor;const u=t.target=e.target;const f=t.targetAnchor=e.targetAnchor;const g=isTeleportDisabled(e.props);const y=g?n:u;const b=g?o:f;i==="svg"||isTargetSVG(u)?i="svg":(i==="mathml"||isTargetMathML(u))&&(i="mathml");if(S){d(e.dynamicChildren,S,y,r,s,i,a);traverseStaticChildren(e,t,true)}else c||p(e,t,y,b,r,s,i,a,false);if(v)g?t.props&&e.props&&t.props.to!==e.props.to&&(t.props.to=e.props.to):moveTeleport(t,n,o,l,1);else if((t.props&&t.props.to)!==(e.props&&e.props.to)){const e=t.target=resolveTarget(t.props,m);e?moveTeleport(t,e,null,l,0):warn$1("Invalid Teleport target on update:",u,`(${typeof u})`)}else g&&moveTeleport(t,u,f,l,1)}updateCssVars(t)},remove(e,t,n,o,{um:r,o:{remove:s}},i){const{shapeFlag:a,children:c,anchor:l,targetAnchor:u,target:p,props:d}=e;p&&s(u);i&&s(l);if(a&16){const e=i||!isTeleportDisabled(d);for(let o=0;o<c.length;o++){const s=c[o];r(s,t,n,e,!!s.dynamicChildren)}}},move:moveTeleport,hydrate:hydrateTeleport};function moveTeleport(e,t,n,{o:{insert:o},m:r},s=2){s===0&&o(e.targetAnchor,t,n);const{el:i,anchor:a,shapeFlag:c,children:l,props:u}=e;const p=s===2;p&&o(i,t,n);if((!p||isTeleportDisabled(u))&&c&16)for(let e=0;e<l.length;e++)r(l[e],t,n,2);p&&o(a,t,n)}function hydrateTeleport(e,t,n,o,r,s,{o:{nextSibling:i,parentNode:a,querySelector:c}},l){const u=t.target=resolveTarget(t.props,c);if(u){const c=u._lpa||u.firstChild;if(t.shapeFlag&16)if(isTeleportDisabled(t.props)){t.anchor=l(i(e),t,a(e),n,o,r,s);t.targetAnchor=c}else{t.anchor=i(e);let a=c;while(a){a=i(a);if(a&&a.nodeType===8&&a.data==="teleport anchor"){t.targetAnchor=a;u._lpa=t.targetAnchor&&i(t.targetAnchor);break}}l(c,t,u,n,o,r,s)}updateCssVars(t)}return t.anchor&&i(t.anchor)}const Nt=Tt;function updateCssVars(e){const t=e.ctx;if(t&&t.ut){let n=e.children[0].el;while(n&&n!==e.targetAnchor){n.nodeType===1&&n.setAttribute("data-v-owner",t.uid);n=n.nextSibling}t.ut()}}const Rt=Symbol.for("v-fgt");const At=Symbol.for("v-txt");const $t=Symbol.for("v-cmt");const Ot=Symbol.for("v-stc");const It=[];let Pt=null;function openBlock(e=false){It.push(Pt=e?null:[])}function closeBlock(){It.pop();Pt=It[It.length-1]||null}let Vt=1;function setBlockTracking(e){Vt+=e}function setupBlock(e){e.dynamicChildren=Vt>0?Pt||t:null;closeBlock();Vt>0&&Pt&&Pt.push(e);return e}function createElementBlock(e,t,n,o,r,s){return setupBlock(createBaseVNode(e,t,n,o,r,s,true))}function createBlock(e,t,n,o,r){return setupBlock(Ft(e,t,n,o,r,true))}function isVNode(e){return!!e&&e.__v_isVNode===true}function isSameVNodeType(e,t){if(t.shapeFlag&6&&Re.has(t.type)){e.shapeFlag&=-257;t.shapeFlag&=-513;return false}return e.type===t.type&&e.key===t.key}let Mt;function transformVNodeArgs(e){Mt=e}const createVNodeWithArgsTransform=(...e)=>_createVNode(...Mt?Mt(e,Le):e);const normalizeKey=({key:e})=>e!=null?e:null;const normalizeRef=({ref:e,ref_key:t,ref_for:n})=>{typeof e==="number"&&(e=""+e);return e!=null?isString(e)||isRef(e)||isFunction(e)?{i:Le,r:e,k:t,f:!!n}:e:null};function createBaseVNode(e,t=null,n=null,o=0,r=null,s=(e===Rt?0:1),i=false,a=false){const c={__v_isVNode:true,__v_skip:true,type:e,props:t,key:t&&normalizeKey(t),ref:t&&normalizeRef(t),scopeId:He,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:s,patchFlag:o,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:Le};if(a){normalizeChildren(c,n);s&128&&e.normalize(c)}else n&&(c.shapeFlag|=isString(n)?8:16);c.key!==c.key&&warn$1("VNode created with invalid key (NaN). VNode type:",c.type);Vt>0&&!i&&Pt&&(c.patchFlag>0||s&6)&&c.patchFlag!==32&&Pt.push(c);return c}const Ft=createVNodeWithArgsTransform;function _createVNode(e,t=null,o=null,s=0,i=null,a=false){if(!e||e===ze){e||warn$1(`Invalid vnode type when creating vnode: ${e}.`);e=$t}if(isVNode(e)){const n=cloneVNode(e,t,true);o&&normalizeChildren(n,o);Vt>0&&!a&&Pt&&(n.shapeFlag&6?Pt[Pt.indexOf(e)]=n:Pt.push(n));n.patchFlag|=-2;return n}isClassComponent(e)&&(e=e.__vccOpts);if(t){t=guardReactiveProps(t);let{class:e,style:o}=t;e&&!isString(e)&&(t.class=normalizeClass(e));if(isObject(o)){isProxy(o)&&!r(o)&&(o=n({},o));t.style=normalizeStyle(o)}}const c=isString(e)?1:isSuspense(e)?128:isTeleport(e)?64:isObject(e)?4:isFunction(e)?2:0;if(c&4&&isProxy(e)){e=toRaw(e);warn$1("Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.","\nComponent that was made reactive: ",e)}return createBaseVNode(e,t,o,s,i,c,a,true)}function guardReactiveProps(e){return e?isProxy(e)||isInternalObject(e)?n({},e):e:null}function cloneVNode(e,t,n=false){const{props:o,ref:s,patchFlag:i,children:a}=e;const c=t?mergeProps(o||{},t):o;const l={__v_isVNode:true,__v_skip:true,type:e.type,props:c,key:c&&normalizeKey(c),ref:t&&t.ref?n&&s?r(s)?s.concat(normalizeRef(t)):[s,normalizeRef(t)]:normalizeRef(t):s,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:i===-1&&r(a)?a.map(deepCloneVNode):a,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==Rt?i===-1?16:i|16:i,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&cloneVNode(e.ssContent),ssFallback:e.ssFallback&&cloneVNode(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return l}function deepCloneVNode(e){const t=cloneVNode(e);r(e.children)&&(t.children=e.children.map(deepCloneVNode));return t}function createTextVNode(e=" ",t=0){return Ft(At,null,e,t)}function createStaticVNode(e,t){const n=Ft(Ot,null,e);n.staticCount=t;return n}function createCommentVNode(e="",t=false){return t?(openBlock(),createBlock($t,null,e)):Ft($t,null,e)}function normalizeVNode(e){return e==null||typeof e==="boolean"?Ft($t):r(e)?Ft(Rt,null,e.slice()):typeof e==="object"?cloneIfMounted(e):Ft(At,null,String(e))}function cloneIfMounted(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:cloneVNode(e)}function normalizeChildren(e,t){let n=0;const{shapeFlag:o}=e;if(t==null)t=null;else if(r(t))n=16;else if(typeof t==="object"){if(o&65){const n=t.default;if(n){n._c&&(n._d=false);normalizeChildren(e,n());n._c&&(n._d=true)}return}{n=32;const o=t._;if(o||isInternalObject(t)){if(o===3&&Le)if(Le.slots._===1)t._=1;else{t._=2;e.patchFlag|=1024}}else t._ctx=Le}}else if(isFunction(t)){t={default:t,_ctx:Le};n=32}else{t=String(t);if(o&64){n=16;t=[createTextVNode(t)]}else n=8}e.children=t;e.shapeFlag|=n}function mergeProps(...e){const t={};for(let n=0;n<e.length;n++){const o=e[n];for(const e in o)if(e==="class")t.class!==o.class&&(t.class=normalizeClass([t.class,o.class]));else if(e==="style")t.style=normalizeStyle([t.style,o.style]);else if(isOn(e)){const n=t[e];const s=o[e];!s||n===s||r(n)&&n.includes(s)||(t[e]=n?[].concat(n,s):s)}else e!==""&&(t[e]=o[e])}return t}function invokeVNodeHook(e,t,n,o=null){callWithAsyncErrorHandling(e,t,7,[n,o])}const Dt=createAppContext();let Lt=0;function createComponentInstance(t,n,o){const r=t.type;const s=(n?n.appContext:t.appContext)||Dt;const i={uid:Lt++,vnode:t,type:r,parent:n,appContext:s,root:null,next:null,subTree:null,effect:null,update:null,scope:new EffectScope(true),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:n?n.provides:Object.create(s.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:normalizePropsOptions(r,s),emitsOptions:normalizeEmitsOptions(r,s),emit:null,emitted:null,propsDefaults:e,inheritAttrs:r.inheritAttrs,ctx:e,data:e,props:e,attrs:e,slots:e,refs:e,setupState:e,setupContext:null,attrsProxy:null,slotsProxy:null,suspense:o,suspenseId:o?o.pendingId:0,asyncDep:null,asyncResolved:false,isMounted:false,isUnmounted:false,isDeactivated:false,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};i.ctx=createDevRenderContext(i);i.root=n?n.root:i;i.emit=emit.bind(null,i);t.ce&&t.ce(i);return i}let Ht=null;const getCurrentInstance=()=>Ht||Le;let jt;let Bt;jt=e=>{Ht=e};Bt=e=>{zt=e};const setCurrentInstance=e=>{const t=Ht;jt(e);e.scope.on();return()=>{e.scope.off();jt(t)}};const unsetCurrentInstance=()=>{Ht&&Ht.scope.off();jt(null)};const Ut=makeMap("slot,component");function validateComponentName(e,{isNativeTag:t}){(Ut(e)||t(e))&&warn$1("Do not use built-in or reserved HTML elements as component id: "+e)}function isStatefulComponent(e){return e.vnode.shapeFlag&4}let zt=false;function setupComponent(e,t=false){t&&Bt(t);const{props:n,children:o}=e.vnode;const r=isStatefulComponent(e);initProps(e,n,r,t);initSlots(e,o);const s=r?setupStatefulComponent(e,t):void 0;t&&Bt(false);return s}function setupStatefulComponent(e,t){var n;const o=e.type;o.name&&validateComponentName(o.name,e.appContext.config);if(o.components){const t=Object.keys(o.components);for(let n=0;n<t.length;n++)validateComponentName(t[n],e.appContext.config)}if(o.directives){const e=Object.keys(o.directives);for(let t=0;t<e.length;t++)validateDirectiveName(e[t])}o.compilerOptions&&isRuntimeOnly()&&warn$1('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');e.accessCache=Object.create(null);e.proxy=new Proxy(e.ctx,mt);exposePropsOnRenderContext(e);const{setup:r}=o;if(r){const s=e.setupContext=r.length>1?createSetupContext(e):null;const i=setCurrentInstance(e);pauseTracking();const a=callWithErrorHandling(r,e,0,[shallowReadonly(e.props),s]);resetTracking();i();if(isPromise(a)){a.then(unsetCurrentInstance,unsetCurrentInstance);if(t)return a.then((n=>{handleSetupResult(e,n,t)})).catch((t=>{handleError(t,e,0)}));e.asyncDep=a;if(!e.suspense){const e=(n=o.name)!=null?n:"Anonymous";warn$1(`Component <${e}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`)}}else handleSetupResult(e,a,t)}else finishComponentSetup(e,t)}function handleSetupResult(e,t,n){if(isFunction(t))e.render=t;else if(isObject(t)){isVNode(t)&&warn$1("setup() should not return VNodes directly - return a render function instead.");e.devtoolsRawSetupState=t;e.setupState=proxyRefs(t);exposeSetupStateOnRenderContext(e)}else t!==void 0&&warn$1("setup() should return an object. Received: "+(t===null?"null":typeof t));finishComponentSetup(e,n)}let Wt;let qt;function registerRuntimeCompiler(e){Wt=e;qt=e=>{e.render._rc&&(e.withProxy=new Proxy(e.ctx,gt))}}const isRuntimeOnly=()=>!Wt;function finishComponentSetup(e,t,o){const r=e.type;if(!e.render){if(!t&&Wt&&!r.render){const t=r.template||resolveMergedOptions(e).template;if(t){startMeasure(e,"compile");const{isCustomElement:o,compilerOptions:s}=e.appContext.config;const{delimiters:i,compilerOptions:a}=r;const c=n(n({isCustomElement:o,delimiters:i},s),a);r.render=Wt(t,c);endMeasure(e,"compile")}}e.render=r.render||NOOP;qt&&qt(e)}{const t=setCurrentInstance(e);pauseTracking();try{applyOptions(e)}finally{resetTracking();t()}}r.render||e.render!==NOOP||t||(!Wt&&r.template?warn$1('Component provided template option but runtime compilation is not supported in this build of Vue. Use "vue.esm-browser.js" instead.'):warn$1("Component is missing template or render function."))}const Kt={get(e,t){markAttrsAccessed();track(e,"get","");return e[t]},set(){warn$1("setupContext.attrs is readonly.");return false},deleteProperty(){warn$1("setupContext.attrs is readonly.");return false}};function getSlotsProxy(e){return e.slotsProxy||(e.slotsProxy=new Proxy(e.slots,{get(t,n){track(e,"get","$slots");return t[n]}}))}function createSetupContext(e){const expose=t=>{e.exposed&&warn$1("expose() should be called only once per setup().");if(t!=null){let e=typeof t;e==="object"&&(r(t)?e="array":isRef(t)&&(e="ref"));e!=="object"&&warn$1(`expose() should be passed a plain object, received ${e}.`)}e.exposed=t||{}};{let t;return Object.freeze({get attrs(){return t||(t=new Proxy(e.attrs,Kt))},get slots(){return getSlotsProxy(e)},get emit(){return(t,...n)=>e.emit(t,...n)},expose:expose})}}function getExposeProxy(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy(proxyRefs(markRaw(e.exposed)),{get(t,n){return n in t?t[n]:n in ht?ht[n](e):void 0},has(e,t){return t in e||t in ht}}))}const Gt=/(?:^|[-_])(\w)/g;const classify=e=>e.replace(Gt,(e=>e.toUpperCase())).replace(/[-_]/g,"");function getComponentName(e,t=true){return isFunction(e)?e.displayName||e.name:e.name||t&&e.__name}function formatComponentName(e,t,n=false){let o=getComponentName(t);if(!o&&t.__file){const e=t.__file.match(/([^/\\]+)\.\w+$/);e&&(o=e[1])}if(!o&&e&&e.parent){const inferFromRegistry=e=>{for(const n in e)if(e[n]===t)return n};o=inferFromRegistry(e.components||e.parent.type.components)||inferFromRegistry(e.appContext.components)}return o?classify(o):n?"App":"Anonymous"}function isClassComponent(e){return isFunction(e)&&"__vccOpts"in e}const computed=(e,t)=>{const n=computed$1(e,t,zt);{const e=getCurrentInstance();e&&e.appContext.config.warnRecursiveComputed&&(n._warnRecursive=true)}return n};function useModel(t,n,o=e){const r=getCurrentInstance();if(!r){warn$1("useModel() called without active instance.");return ref()}if(!r.propsOptions[0][n]){warn$1(`useModel() called with prop "${n}" which is not declared.`);return ref()}const s=l(n);const i=p(n);const a=customRef(((e,a)=>{let c;watchSyncEffect((()=>{const e=t[n];if(hasChanged(c,e)){c=e;a()}}));return{get(){e();return o.get?o.get(c):c},set(e){const t=r.vnode.props;if(!(t&&(n in t||s in t||i in t)&&(`onUpdate:${n}`in t||`onUpdate:${s}`in t||`onUpdate:${i}`in t))&&hasChanged(e,c)){c=e;a()}r.emit(`update:${n}`,o.set?o.set(e):e)}}}));const c=n==="modelValue"?"modelModifiers":`${n}Modifiers`;a[Symbol.iterator]=()=>{let e=0;return{next(){return e<2?{value:e++?t[c]||{}:a,done:false}:{done:true}}}};return a}function h(e,t,n){const o=arguments.length;if(o===2)return isObject(t)&&!r(t)?isVNode(t)?Ft(e,null,[t]):Ft(e,t):Ft(e,null,t);o>3?n=Array.prototype.slice.call(arguments,2):o===3&&isVNode(n)&&(n=[n]);return Ft(e,t,n)}function initCustomFormatter(){if(typeof window==="undefined")return;const t={style:"color:#3ba776"};const o={style:"color:#1677ff"};const s={style:"color:#f5222d"};const i={style:"color:#eb2f96"};const a={header(e){return isObject(e)?e.__isVue?["div",t,"VueInstance"]:isRef(e)?["div",{},["span",t,genRefFlag(e)],"<",formatValue(e.value),">"]:isReactive(e)?["div",{},["span",t,isShallow(e)?"ShallowReactive":"Reactive"],"<",formatValue(e),">"+(isReadonly(e)?" (readonly)":"")]:isReadonly(e)?["div",{},["span",t,isShallow(e)?"ShallowReadonly":"Readonly"],"<",formatValue(e),">"]:null:null},hasBody(e){return e&&e.__isVue},body(e){if(e&&e.__isVue)return["div",{},...formatInstance(e.$)]}};function formatInstance(t){const n=[];t.type.props&&t.props&&n.push(createInstanceBlock("props",toRaw(t.props)));t.setupState!==e&&n.push(createInstanceBlock("setup",t.setupState));t.data!==e&&n.push(createInstanceBlock("data",toRaw(t.data)));const o=extractKeys(t,"computed");o&&n.push(createInstanceBlock("computed",o));const r=extractKeys(t,"inject");r&&n.push(createInstanceBlock("injected",r));n.push(["div",{},["span",{style:i.style+";opacity:0.66"},"$ (internal): "],["object",{object:t}]]);return n}function createInstanceBlock(e,t){t=n({},t);return Object.keys(t).length?["div",{style:"line-height:1.25em;margin-bottom:0.6em"},["div",{style:"color:#476582"},e],["div",{style:"padding-left:1.25em"},...Object.keys(t).map((e=>["div",{},["span",i,e+": "],formatValue(t[e],false)]))]]:["span",{}]}function formatValue(e,t=true){return typeof e==="number"?["span",o,e]:typeof e==="string"?["span",s,JSON.stringify(e)]:typeof e==="boolean"?["span",i,e]:isObject(e)?["object",{object:t?toRaw(e):e}]:["span",s,String(e)]}function extractKeys(e,t){const n=e.type;if(isFunction(n))return;const o={};for(const r in e.ctx)isKeyOfType(n,r,t)&&(o[r]=e.ctx[r]);return o}function isKeyOfType(e,t,n){const o=e[n];return!!(r(o)&&o.includes(t)||isObject(o)&&t in o)||(!(!e.extends||!isKeyOfType(e.extends,t,n))||(!(!e.mixins||!e.mixins.some((e=>isKeyOfType(e,t,n))))||void 0))}function genRefFlag(e){return isShallow(e)?"ShallowRef":e.effect?"ComputedRef":"Ref"}window.devtoolsFormatters?window.devtoolsFormatters.push(a):window.devtoolsFormatters=[a]}function withMemo(e,t,n,o){const r=n[o];if(r&&isMemoSame(r,e))return r;const s=t();s.memo=e.slice();return n[o]=s}function isMemoSame(e,t){const n=e.memo;if(n.length!=t.length)return false;for(let e=0;e<n.length;e++)if(hasChanged(n[e],t[e]))return false;Vt>0&&Pt&&Pt.push(e);return true}const Jt="3.4.23";const Yt=warn$1;const Xt=ye;const Qt=$e;const Zt=setDevtoolsHook$1;const en=null;const tn=null;const nn=null;const on=null;const rn="http://www.w3.org/2000/svg";const sn="http://www.w3.org/1998/Math/MathML";const an=typeof document!=="undefined"?document:null;const cn=an&&an.createElement("template");const ln={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,o)=>{const r=t==="svg"?an.createElementNS(rn,e):t==="mathml"?an.createElementNS(sn,e):an.createElement(e,n?{is:n}:void 0);e==="select"&&o&&o.multiple!=null&&r.setAttribute("multiple",o.multiple);return r},createText:e=>an.createTextNode(e),createComment:e=>an.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>an.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,n,o,r,s){const i=n?n.previousSibling:t.lastChild;if(r&&(r===s||r.nextSibling))while(true){t.insertBefore(r.cloneNode(true),n);if(r===s||!(r=r.nextSibling))break}else{cn.innerHTML=o==="svg"?`<svg>${e}</svg>`:o==="mathml"?`<math>${e}</math>`:e;const r=cn.content;if(o==="svg"||o==="mathml"){const e=r.firstChild;while(e.firstChild)r.appendChild(e.firstChild);r.removeChild(e)}t.insertBefore(r,n)}return[i?i.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}};const un="transition";const pn="animation";const dn=Symbol("_vtc");const Transition=(e,{slots:t})=>h(nt,resolveTransitionProps(e),t);Transition.displayName="Transition";const fn={name:String,type:String,css:{type:Boolean,default:true},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};const hn=Transition.props=n({},et,fn);const callHook=(e,t=[])=>{r(e)?e.forEach((e=>e(...t))):e&&e(...t)};const hasExplicitCallback=e=>!!e&&(r(e)?e.some((e=>e.length>1)):e.length>1);function resolveTransitionProps(e){const t={};for(const n in e)n in fn||(t[n]=e[n]);if(e.css===false)return t;const{name:o="v",type:r,duration:s,enterFromClass:i=`${o}-enter-from`,enterActiveClass:a=`${o}-enter-active`,enterToClass:c=`${o}-enter-to`,appearFromClass:l=i,appearActiveClass:u=a,appearToClass:p=c,leaveFromClass:d=`${o}-leave-from`,leaveActiveClass:f=`${o}-leave-active`,leaveToClass:m=`${o}-leave-to`}=e;const g=normalizeDuration(s);const y=g&&g[0];const v=g&&g[1];const{onBeforeEnter:b,onEnter:C,onEnterCancelled:S,onLeave:x,onLeaveCancelled:w,onBeforeAppear:E=b,onAppear:k=C,onAppearCancelled:_=S}=t;const finishEnter=(e,t,n)=>{removeTransitionClass(e,t?p:c);removeTransitionClass(e,t?u:a);n&&n()};const finishLeave=(e,t)=>{e._isLeaving=false;removeTransitionClass(e,d);removeTransitionClass(e,m);removeTransitionClass(e,f);t&&t()};const makeEnterHook=e=>(t,n)=>{const o=e?k:C;const resolve=()=>finishEnter(t,e,n);callHook(o,[t,resolve]);nextFrame((()=>{removeTransitionClass(t,e?l:i);addTransitionClass(t,e?p:c);hasExplicitCallback(o)||whenTransitionEnds(t,r,y,resolve)}))};return n(t,{onBeforeEnter(e){callHook(b,[e]);addTransitionClass(e,i);addTransitionClass(e,a)},onBeforeAppear(e){callHook(E,[e]);addTransitionClass(e,l);addTransitionClass(e,u)},onEnter:makeEnterHook(false),onAppear:makeEnterHook(true),onLeave(e,t){e._isLeaving=true;const resolve=()=>finishLeave(e,t);addTransitionClass(e,d);forceReflow();addTransitionClass(e,f);nextFrame((()=>{if(e._isLeaving){removeTransitionClass(e,d);addTransitionClass(e,m);hasExplicitCallback(x)||whenTransitionEnds(e,r,v,resolve)}}));callHook(x,[e,resolve])},onEnterCancelled(e){finishEnter(e,false);callHook(S,[e])},onAppearCancelled(e){finishEnter(e,true);callHook(_,[e])},onLeaveCancelled(e){finishLeave(e);callHook(w,[e])}})}function normalizeDuration(e){if(e==null)return null;if(isObject(e))return[NumberOf(e.enter),NumberOf(e.leave)];{const t=NumberOf(e);return[t,t]}}function NumberOf(e){const t=toNumber(e);assertNumber(t,"<transition> explicit duration");return t}function addTransitionClass(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.add(t)));(e[dn]||(e[dn]=new Set)).add(t)}function removeTransitionClass(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.remove(t)));const n=e[dn];if(n){n.delete(t);n.size||(e[dn]=void 0)}}function nextFrame(e){requestAnimationFrame((()=>{requestAnimationFrame(e)}))}let mn=0;function whenTransitionEnds(e,t,n,o){const r=e._endId=++mn;const resolveIfNotStale=()=>{r===e._endId&&o()};if(n)return setTimeout(resolveIfNotStale,n);const{type:s,timeout:i,propCount:a}=getTransitionInfo(e,t);if(!s)return o();const c=s+"end";let l=0;const end=()=>{e.removeEventListener(c,onEnd);resolveIfNotStale()};const onEnd=t=>{t.target===e&&++l>=a&&end()};setTimeout((()=>{l<a&&end()}),i+1);e.addEventListener(c,onEnd)}function getTransitionInfo(e,t){const n=window.getComputedStyle(e);const getStyleProperties=e=>(n[e]||"").split(", ");const o=getStyleProperties(`${un}Delay`);const r=getStyleProperties(`${un}Duration`);const s=getTimeout(o,r);const i=getStyleProperties(`${pn}Delay`);const a=getStyleProperties(`${pn}Duration`);const c=getTimeout(i,a);let l=null;let u=0;let p=0;if(t===un){if(s>0){l=un;u=s;p=r.length}}else if(t===pn){if(c>0){l=pn;u=c;p=a.length}}else{u=Math.max(s,c);l=u>0?s>c?un:pn:null;p=l?l===un?r.length:a.length:0}const d=l===un&&/\b(transform|all)(,|$)/.test(getStyleProperties(`${un}Property`).toString());return{type:l,timeout:u,propCount:p,hasTransform:d}}function getTimeout(e,t){while(e.length<t.length)e=e.concat(e);return Math.max(...t.map(((t,n)=>toMs(t)+toMs(e[n]))))}function toMs(e){return e==="auto"?0:Number(e.slice(0,-1).replace(",","."))*1e3}function forceReflow(){return document.body.offsetHeight}function patchClass(e,t,n){const o=e[dn];o&&(t=(t?[t,...o]:[...o]).join(" "));t==null?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}const gn=Symbol("_vod");const yn=Symbol("_vsh");const vn={beforeMount(e,{value:t},{transition:n}){e[gn]=e.style.display==="none"?"":e.style.display;n&&t?n.beforeEnter(e):setDisplay(e,t)},mounted(e,{value:t},{transition:n}){n&&t&&n.enter(e)},updated(e,{value:t,oldValue:n},{transition:o}){if(!t!==!n)if(o)if(t){o.beforeEnter(e);setDisplay(e,true);o.enter(e)}else o.leave(e,(()=>{setDisplay(e,false)}));else setDisplay(e,t)},beforeUnmount(e,{value:t}){setDisplay(e,t)}};vn.name="show";function setDisplay(e,t){e.style.display=t?e[gn]:"none";e[yn]=!t}const bn=Symbol("CSS_VAR_TEXT");function useCssVars(e){const t=getCurrentInstance();if(!t){Yt("useCssVars is called without current active component instance.");return}const n=t.ut=(n=e(t.proxy))=>{Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach((e=>setVarsOnNode(e,n)))};t.getCssVars=()=>e(t.proxy);const setVars=()=>{const o=e(t.proxy);setVarsOnVNode(t.subTree,o);n(o)};it((()=>{watchPostEffect(setVars);const e=new MutationObserver(setVars);e.observe(t.subTree.el.parentNode,{childList:true});ut((()=>e.disconnect()))}))}function setVarsOnVNode(e,t){if(e.shapeFlag&128){const n=e.suspense;e=n.activeBranch;n.pendingBranch&&!n.isHydrating&&n.effects.push((()=>{setVarsOnVNode(n.activeBranch,t)}))}while(e.component)e=e.component.subTree;if(e.shapeFlag&1&&e.el)setVarsOnNode(e.el,t);else if(e.type===Rt)e.children.forEach((e=>setVarsOnVNode(e,t)));else if(e.type===Ot){let{el:n,anchor:o}=e;while(n){setVarsOnNode(n,t);if(n===o)break;n=n.nextSibling}}}function setVarsOnNode(e,t){if(e.nodeType===1){const n=e.style;let o="";for(const e in t){n.setProperty(`--${e}`,t[e]);o+=`--${e}: ${t[e]};`}n[bn]=o}}const Cn=/(^|;)\s*display\s*:/;function patchStyle(e,t,n){const o=e.style;const r=isString(n);let s=false;if(n&&!r){if(t)if(isString(t))for(const e of t.split(";")){const t=e.slice(0,e.indexOf(":")).trim();n[t]==null&&setStyle(o,t,"")}else for(const e in t)n[e]==null&&setStyle(o,e,"");for(const e in n){e==="display"&&(s=true);setStyle(o,e,n[e])}}else if(r){if(t!==n){const e=o[bn];e&&(n+=";"+e);o.cssText=n;s=Cn.test(n)}}else t&&e.removeAttribute("style");if(gn in e){e[gn]=s?o.display:"";e[yn]&&(o.display="none")}}const Sn=/[^\\];\s*$/;const xn=/\s*!important$/;function setStyle(e,t,n){if(r(n))n.forEach((n=>setStyle(e,t,n)));else{n==null&&(n="");Sn.test(n)&&Yt(`Unexpected semicolon at the end of '${t}' style value: '${n}'`);if(t.startsWith("--"))e.setProperty(t,n);else{const o=autoPrefix(e,t);xn.test(n)?e.setProperty(p(o),n.replace(xn,""),"important"):e[o]=n}}}const wn=["Webkit","Moz","ms"];const En={};function autoPrefix(e,t){const n=En[t];if(n)return n;let o=l(t);if(o!=="filter"&&o in e)return En[t]=o;o=d(o);for(let n=0;n<wn.length;n++){const r=wn[n]+o;if(r in e)return En[t]=r}return t}const kn="http://www.w3.org/1999/xlink";function patchAttr(e,t,n,o,r){if(o&&t.startsWith("xlink:"))n==null?e.removeAttributeNS(kn,t.slice(6,t.length)):e.setAttributeNS(kn,t,n);else{const o=I(t);n==null||o&&!includeBooleanAttr(n)?e.removeAttribute(t):e.setAttribute(t,o?"":n)}}function patchDOMProp(e,t,n,o,r,s,i){if(t==="innerHTML"||t==="textContent"){o&&i(o,r,s);e[t]=n==null?"":n;return}const a=e.tagName;if(t==="value"&&a!=="PROGRESS"&&!a.includes("-")){const o=a==="OPTION"?e.getAttribute("value")||"":e.value;const r=n==null?"":n;o===r&&"_value"in e||(e.value=r);n==null&&e.removeAttribute(t);e._value=n;return}let c=false;if(n===""||n==null){const o=typeof e[t];if(o==="boolean")n=includeBooleanAttr(n);else if(n==null&&o==="string"){n="";c=true}else if(o==="number"){n=0;c=true}}try{e[t]=n}catch(e){c||Yt(`Failed setting prop "${t}" on <${a.toLowerCase()}>: value ${n} is invalid.`,e)}c&&e.removeAttribute(t)}function addEventListener(e,t,n,o){e.addEventListener(t,n,o)}function removeEventListener(e,t,n,o){e.removeEventListener(t,n,o)}const _n=Symbol("_vei");function patchEvent(e,t,n,o,r=null){const s=e[_n]||(e[_n]={});const i=s[t];if(o&&i)i.value=sanitizeEventValue(o,t);else{const[n,a]=parseName(t);if(o){const i=s[t]=createInvoker(sanitizeEventValue(o,t),r);addEventListener(e,n,i,a)}else if(i){removeEventListener(e,n,i,a);s[t]=void 0}}}const Tn=/(?:Once|Passive|Capture)$/;function parseName(e){let t;if(Tn.test(e)){t={};let n;while(n=e.match(Tn)){e=e.slice(0,e.length-n[0].length);t[n[0].toLowerCase()]=true}}const n=e[2]===":"?e.slice(3):p(e.slice(2));return[n,t]}let Nn=0;const Rn=Promise.resolve();const getNow=()=>Nn||(Rn.then((()=>Nn=0)),Nn=Date.now());function createInvoker(e,t){const invoker=e=>{if(e._vts){if(e._vts<=invoker.attached)return}else e._vts=Date.now();callWithAsyncErrorHandling(patchStopImmediatePropagation(e,invoker.value),t,5,[e])};invoker.value=e;invoker.attached=getNow();return invoker}function sanitizeEventValue(e,t){if(isFunction(e)||r(e))return e;Yt(`Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?\nExpected function or array of functions, received type ${typeof e}.`);return NOOP}function patchStopImmediatePropagation(e,t){if(r(t)){const n=e.stopImmediatePropagation;e.stopImmediatePropagation=()=>{n.call(e);e._stopped=true};return t.map((e=>t=>!t._stopped&&e&&e(t)))}return t}const isNativeOn=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123;const patchProp=(e,t,n,o,r,s,i,a,c)=>{const l=r==="svg";if(t==="class")patchClass(e,o,l);else if(t==="style")patchStyle(e,n,o);else if(isOn(t))isModelListener(t)||patchEvent(e,t,n,o,i);else if(t[0]==="."?(t=t.slice(1),true):t[0]==="^"?(t=t.slice(1),false):shouldSetAsProp(e,t,o,l))patchDOMProp(e,t,o,s,i,a,c);else{t==="true-value"?e._trueValue=o:t==="false-value"&&(e._falseValue=o);patchAttr(e,t,o,l)}};function shouldSetAsProp(e,t,n,o){if(o)return t==="innerHTML"||t==="textContent"||!!(t in e&&isNativeOn(t)&&isFunction(n));if(t==="spellcheck"||t==="draggable"||t==="translate")return false;if(t==="form")return false;if(t==="list"&&e.tagName==="INPUT")return false;if(t==="type"&&e.tagName==="TEXTAREA")return false;if(t==="width"||t==="height"){const t=e.tagName;if(t==="IMG"||t==="VIDEO"||t==="CANVAS"||t==="SOURCE")return false}return(!isNativeOn(t)||!isString(n))&&t in e}function defineCustomElement(e,t){const n=defineComponent(e);class VueCustomElement extends VueElement{constructor(e){super(n,e,t)}}VueCustomElement.def=n;return VueCustomElement}const defineSSRCustomElement=e=>defineCustomElement(e,hydrate);const An=typeof HTMLElement!=="undefined"?HTMLElement:class{};class VueElement extends An{constructor(e,t={},n){super();this._def=e;this._props=t;this._instance=null;this._connected=false;this._resolved=false;this._numberProps=null;this._ob=null;if(this.shadowRoot&&n)n(this._createVNode(),this.shadowRoot);else{this.shadowRoot&&Yt("Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`.");this.attachShadow({mode:"open"});this._def.__asyncLoader||this._resolveProps(this._def)}}connectedCallback(){this._connected=true;this._instance||(this._resolved?this._update():this._resolveDef())}disconnectedCallback(){this._connected=false;if(this._ob){this._ob.disconnect();this._ob=null}nextTick((()=>{if(!this._connected){render(null,this.shadowRoot);this._instance=null}}))}_resolveDef(){this._resolved=true;for(let e=0;e<this.attributes.length;e++)this._setAttr(this.attributes[e].name);this._ob=new MutationObserver((e=>{for(const t of e)this._setAttr(t.attributeName)}));this._ob.observe(this,{attributes:true});const resolve=(e,t=false)=>{const{props:n,styles:o}=e;let s;if(n&&!r(n))for(const e in n){const t=n[e];if(t===Number||t&&t.type===Number){e in this._props&&(this._props[e]=toNumber(this._props[e]));(s||(s=Object.create(null)))[l(e)]=true}}this._numberProps=s;t&&this._resolveProps(e);this._applyStyles(o);this._update()};const e=this._def.__asyncLoader;e?e().then((e=>resolve(e,true))):resolve(this._def)}_resolveProps(e){const{props:t}=e;const n=r(t)?t:Object.keys(t||{});for(const e of Object.keys(this))e[0]!=="_"&&n.includes(e)&&this._setProp(e,this[e],true,false);for(const e of n.map(l))Object.defineProperty(this,e,{get(){return this._getProp(e)},set(t){this._setProp(e,t)}})}_setAttr(e){let t=this.hasAttribute(e)?this.getAttribute(e):void 0;const n=l(e);this._numberProps&&this._numberProps[n]&&(t=toNumber(t));this._setProp(n,t,false)}_getProp(e){return this._props[e]}_setProp(e,t,n=true,o=true){if(t!==this._props[e]){this._props[e]=t;o&&this._instance&&this._update();n&&(t===true?this.setAttribute(p(e),""):typeof t==="string"||typeof t==="number"?this.setAttribute(p(e),t+""):t||this.removeAttribute(p(e)))}}_update(){render(this._createVNode(),this.shadowRoot)}_createVNode(){const e=Ft(this._def,n({},this._props));this._instance||(e.ce=e=>{this._instance=e;e.isCE=true;e.ceReload=e=>{if(this._styles){this._styles.forEach((e=>this.shadowRoot.removeChild(e)));this._styles.length=0}this._applyStyles(e);this._instance=null;this._update()};const dispatch=(e,t)=>{this.dispatchEvent(new CustomEvent(e,{detail:t}))};e.emit=(e,...t)=>{dispatch(e,t);p(e)!==e&&dispatch(p(e),t)};let t=this;while(t=t&&(t.parentNode||t.host))if(t instanceof VueElement){e.parent=t._instance;e.provides=t._instance.provides;break}});return e}_applyStyles(e){e&&e.forEach((e=>{const t=document.createElement("style");t.textContent=e;this.shadowRoot.appendChild(t);(this._styles||(this._styles=[])).push(t)}))}}function useCssModule(t="$style"){{const n=getCurrentInstance();if(!n){Yt("useCssModule must be called inside setup()");return e}const o=n.type.__cssModules;if(!o){Yt("Current instance does not have CSS modules injected.");return e}const r=o[t];if(!r){Yt(`Current instance does not have CSS module named "${t}".`);return e}return r}}const $n=new WeakMap;const On=new WeakMap;const In=Symbol("_moveCb");const Pn=Symbol("_enterCb");const Vn={name:"TransitionGroup",props:n({},hn,{tag:String,moveClass:String}),setup(e,{slots:t}){const n=getCurrentInstance();const o=useTransitionState();let r;let s;ct((()=>{if(!r.length)return;const t=e.moveClass||`${e.name||"v"}-move`;if(!hasCSSTransform(r[0].el,n.vnode.el,t))return;r.forEach(callPendingCbs);r.forEach(recordPosition);const o=r.filter(applyTranslation);forceReflow();o.forEach((e=>{const n=e.el;const o=n.style;addTransitionClass(n,t);o.transform=o.webkitTransform=o.transitionDuration="";const r=n[In]=e=>{if((!e||e.target===n)&&(!e||/transform$/.test(e.propertyName))){n.removeEventListener("transitionend",r);n[In]=null;removeTransitionClass(n,t)}};n.addEventListener("transitionend",r)}))}));return()=>{const i=toRaw(e);const a=resolveTransitionProps(i);let c=i.tag||Rt;r=[];if(s)for(let e=0;e<s.length;e++){const t=s[e];if(t.el&&t.el instanceof Element){r.push(t);setTransitionHooks(t,resolveTransitionHooks(t,a,o,n));$n.set(t,t.el.getBoundingClientRect())}}s=t.default?getTransitionRawChildren(t.default()):[];for(let e=0;e<s.length;e++){const t=s[e];t.key!=null?setTransitionHooks(t,resolveTransitionHooks(t,a,o,n)):Yt("<TransitionGroup> children must be keyed.")}return Ft(c,null,s)}}};const removeMode=e=>delete e.mode;removeMode(Vn.props);const Mn=Vn;function callPendingCbs(e){const t=e.el;t[In]&&t[In]();t[Pn]&&t[Pn]()}function recordPosition(e){On.set(e,e.el.getBoundingClientRect())}function applyTranslation(e){const t=$n.get(e);const n=On.get(e);const o=t.left-n.left;const r=t.top-n.top;if(o||r){const t=e.el.style;t.transform=t.webkitTransform=`translate(${o}px,${r}px)`;t.transitionDuration="0s";return e}}function hasCSSTransform(e,t,n){const o=e.cloneNode();const r=e[dn];r&&r.forEach((e=>{e.split(/\s+/).forEach((e=>e&&o.classList.remove(e)))}));n.split(/\s+/).forEach((e=>e&&o.classList.add(e)));o.style.display="none";const s=t.nodeType===1?t:t.parentNode;s.appendChild(o);const{hasTransform:i}=getTransitionInfo(o);s.removeChild(o);return i}const getModelAssigner=e=>{const t=e.props["onUpdate:modelValue"]||false;return r(t)?e=>invokeArrayFns(t,e):t};function onCompositionStart(e){e.target.composing=true}function onCompositionEnd(e){const t=e.target;if(t.composing){t.composing=false;t.dispatchEvent(new Event("input"))}}const Fn=Symbol("_assign");const Dn={created(e,{modifiers:{lazy:t,trim:n,number:o}},r){e[Fn]=getModelAssigner(r);const s=o||r.props&&r.props.type==="number";addEventListener(e,t?"change":"input",(t=>{if(t.target.composing)return;let o=e.value;n&&(o=o.trim());s&&(o=looseToNumber(o));e[Fn](o)}));n&&addEventListener(e,"change",(()=>{e.value=e.value.trim()}));if(!t){addEventListener(e,"compositionstart",onCompositionStart);addEventListener(e,"compositionend",onCompositionEnd);addEventListener(e,"change",onCompositionEnd)}},mounted(e,{value:t}){e.value=t==null?"":t},beforeUpdate(e,{value:t,modifiers:{lazy:n,trim:o,number:r}},s){e[Fn]=getModelAssigner(s);if(e.composing)return;const i=!r&&e.type!=="number"||/^0\d/.test(e.value)?e.value:looseToNumber(e.value);const a=t==null?"":t;if(i!==a){if(document.activeElement===e&&e.type!=="range"){if(n)return;if(o&&e.value.trim()===a)return}e.value=a}}};const Ln={deep:true,created(e,t,n){e[Fn]=getModelAssigner(n);addEventListener(e,"change",(()=>{const t=e._modelValue;const n=getValue(e);const o=e.checked;const s=e[Fn];if(r(t)){const e=looseIndexOf(t,n);const r=e!==-1;if(o&&!r)s(t.concat(n));else if(!o&&r){const n=[...t];n.splice(e,1);s(n)}}else if(isSet(t)){const e=new Set(t);o?e.add(n):e.delete(n);s(e)}else s(getCheckboxValue(e,o))}))},mounted:setChecked,beforeUpdate(e,t,n){e[Fn]=getModelAssigner(n);setChecked(e,t,n)}};function setChecked(e,{value:t,oldValue:n},o){e._modelValue=t;r(t)?e.checked=looseIndexOf(t,o.props.value)>-1:isSet(t)?e.checked=t.has(o.props.value):t!==n&&(e.checked=looseEqual(t,getCheckboxValue(e,true)))}const Hn={created(e,{value:t},n){e.checked=looseEqual(t,n.props.value);e[Fn]=getModelAssigner(n);addEventListener(e,"change",(()=>{e[Fn](getValue(e))}))},beforeUpdate(e,{value:t,oldValue:n},o){e[Fn]=getModelAssigner(o);t!==n&&(e.checked=looseEqual(t,o.props.value))}};const jn={deep:true,created(e,{value:t,modifiers:{number:n}},o){const r=isSet(t);addEventListener(e,"change",(()=>{const t=Array.prototype.filter.call(e.options,(e=>e.selected)).map((e=>n?looseToNumber(getValue(e)):getValue(e)));e[Fn](e.multiple?r?new Set(t):t:t[0]);e._assigning=true;nextTick((()=>{e._assigning=false}))}));e[Fn]=getModelAssigner(o)},mounted(e,{value:t,modifiers:{number:n}}){setSelected(e,t)},beforeUpdate(e,t,n){e[Fn]=getModelAssigner(n)},updated(e,{value:t,modifiers:{number:n}}){e._assigning||setSelected(e,t)}};function setSelected(e,t,n){const o=e.multiple;const s=r(t);if(!o||s||isSet(t)){for(let n=0,r=e.options.length;n<r;n++){const r=e.options[n];const i=getValue(r);if(o)if(s){const e=typeof i;r.selected=e==="string"||e==="number"?t.some((e=>String(e)===String(i))):looseIndexOf(t,i)>-1}else r.selected=t.has(i);else if(looseEqual(getValue(r),t)){e.selectedIndex!==n&&(e.selectedIndex=n);return}}o||e.selectedIndex===-1||(e.selectedIndex=-1)}else Yt(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(t).slice(8,-1)}.`)}function getValue(e){return"_value"in e?e._value:e.value}function getCheckboxValue(e,t){const n=t?"_trueValue":"_falseValue";return n in e?e[n]:t}const Bn={created(e,t,n){callModelHook(e,t,n,null,"created")},mounted(e,t,n){callModelHook(e,t,n,null,"mounted")},beforeUpdate(e,t,n,o){callModelHook(e,t,n,o,"beforeUpdate")},updated(e,t,n,o){callModelHook(e,t,n,o,"updated")}};function resolveDynamicModel(e,t){switch(e){case"SELECT":return jn;case"TEXTAREA":return Dn;default:switch(t){case"checkbox":return Ln;case"radio":return Hn;default:return Dn}}}function callModelHook(e,t,n,o,r){const s=resolveDynamicModel(e.tagName,n.props&&n.props.type);const i=s[r];i&&i(e,t,n,o)}const Un=["ctrl","shift","alt","meta"];const zn={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,t)=>Un.some((n=>e[`${n}Key`]&&!t.includes(n)))};const withModifiers=(e,t)=>{const n=e._withMods||(e._withMods={});const o=t.join(".");return n[o]||(n[o]=(n,...o)=>{for(let e=0;e<t.length;e++){const o=zn[t[e]];if(o&&o(n,t))return}return e(n,...o)})};const Wn={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"};const withKeys=(e,t)=>{const n=e._withKeys||(e._withKeys={});const o=t.join(".");return n[o]||(n[o]=n=>{if(!("key"in n))return;const o=p(n.key);return t.some((e=>e===o||Wn[e]===o))?e(n):void 0})};const qn=n({patchProp:patchProp},ln);let Kn;let Gn=false;function ensureRenderer(){return Kn||(Kn=createRenderer(qn))}function ensureHydrationRenderer(){Kn=Gn?Kn:createHydrationRenderer(qn);Gn=true;return Kn}const render=(...e)=>{ensureRenderer().render(...e)};const hydrate=(...e)=>{ensureHydrationRenderer().hydrate(...e)};const createApp=(...e)=>{const t=ensureRenderer().createApp(...e);injectNativeTagCheck(t);injectCompilerOptionsCheck(t);const{mount:n}=t;t.mount=e=>{const o=normalizeContainer(e);if(!o)return;const r=t._component;isFunction(r)||r.render||r.template||(r.template=o.innerHTML);o.innerHTML="";const s=n(o,false,resolveRootNamespace(o));if(o instanceof Element){o.removeAttribute("v-cloak");o.setAttribute("data-v-app","")}return s};return t};const createSSRApp=(...e)=>{const t=ensureHydrationRenderer().createApp(...e);injectNativeTagCheck(t);injectCompilerOptionsCheck(t);const{mount:n}=t;t.mount=e=>{const t=normalizeContainer(e);if(t)return n(t,true,resolveRootNamespace(t))};return t};function resolveRootNamespace(e){return e instanceof SVGElement?"svg":typeof MathMLElement==="function"&&e instanceof MathMLElement?"mathml":void 0}function injectNativeTagCheck(e){Object.defineProperty(e.config,"isNativeTag",{value:e=>N(e)||R(e)||A(e),writable:false})}function injectCompilerOptionsCheck(e){if(isRuntimeOnly()){const t=e.config.isCustomElement;Object.defineProperty(e.config,"isCustomElement",{get(){return t},set(){Yt("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.")}});const n=e.config.compilerOptions;const o='The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';Object.defineProperty(e.config,"compilerOptions",{get(){Yt(o);return n},set(){Yt(o)}})}}function normalizeContainer(e){if(isString(e)){const t=document.querySelector(e);t||Yt(`Failed to mount app: mount target selector "${e}" returned null.`);return t}window.ShadowRoot&&e instanceof window.ShadowRoot&&e.mode==="closed"&&Yt('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs');return e}const Jn=NOOP;var Yn=Object.freeze({__proto__:null,BaseTransition:nt,BaseTransitionPropsValidators:et,Comment:$t,DeprecationTypes:on,EffectScope:EffectScope,ErrorCodes:ge,ErrorTypeStrings:Xt,Fragment:Rt,KeepAlive:rt,ReactiveEffect:ReactiveEffect,Static:Ot,Suspense:Ke,Teleport:Nt,Text:At,TrackOpTypes:fe,Transition:Transition,TransitionGroup:Mn,TriggerOpTypes:he,VueElement:VueElement,assertNumber:assertNumber,callWithAsyncErrorHandling:callWithAsyncErrorHandling,callWithErrorHandling:callWithErrorHandling,camelize:l,capitalize:d,cloneVNode:cloneVNode,compatUtils:nn,computed:computed,createApp:createApp,createBlock:createBlock,createCommentVNode:createCommentVNode,createElementBlock:createElementBlock,createElementVNode:createBaseVNode,createHydrationRenderer:createHydrationRenderer,createPropsRestProxy:createPropsRestProxy,createRenderer:createRenderer,createSSRApp:createSSRApp,createSlots:createSlots,createStaticVNode:createStaticVNode,createTextVNode:createTextVNode,createVNode:Ft,customRef:customRef,defineAsyncComponent:defineAsyncComponent,defineComponent:defineComponent,defineCustomElement:defineCustomElement,defineEmits:defineEmits,defineExpose:defineExpose,defineModel:defineModel,defineOptions:defineOptions,defineProps:defineProps,defineSSRCustomElement:defineSSRCustomElement,defineSlots:defineSlots,devtools:Qt,effect:effect,effectScope:effectScope,getCurrentInstance:getCurrentInstance,getCurrentScope:getCurrentScope,getTransitionRawChildren:getTransitionRawChildren,guardReactiveProps:guardReactiveProps,h:h,handleError:handleError,hasInjectionContext:hasInjectionContext,hydrate:hydrate,initCustomFormatter:initCustomFormatter,initDirectivesForSSR:Jn,inject:inject,isMemoSame:isMemoSame,isProxy:isProxy,isReactive:isReactive,isReadonly:isReadonly,isRef:isRef,isRuntimeOnly:isRuntimeOnly,isShallow:isShallow,isVNode:isVNode,markRaw:markRaw,mergeDefaults:mergeDefaults,mergeModels:mergeModels,mergeProps:mergeProps,nextTick:nextTick,normalizeClass:normalizeClass,normalizeProps:normalizeProps,normalizeStyle:normalizeStyle,onActivated:onActivated,onBeforeMount:st,onBeforeUnmount:lt,onBeforeUpdate:at,onDeactivated:onDeactivated,onErrorCaptured:onErrorCaptured,onMounted:it,onRenderTracked:ft,onRenderTriggered:dt,onScopeDispose:onScopeDispose,onServerPrefetch:pt,onUnmounted:ut,onUpdated:ct,openBlock:openBlock,popScopeId:popScopeId,provide:provide,proxyRefs:proxyRefs,pushScopeId:pushScopeId,queuePostFlushCb:queuePostFlushCb,reactive:reactive,readonly:readonly,ref:ref,registerRuntimeCompiler:registerRuntimeCompiler,render:render,renderList:renderList,renderSlot:renderSlot,resolveComponent:resolveComponent,resolveDirective:resolveDirective,resolveDynamicComponent:resolveDynamicComponent,resolveFilter:tn,resolveTransitionHooks:resolveTransitionHooks,setBlockTracking:setBlockTracking,setDevtoolsHook:Zt,setTransitionHooks:setTransitionHooks,shallowReactive:shallowReactive,shallowReadonly:shallowReadonly,shallowRef:shallowRef,ssrContextKey:Je,ssrUtils:en,stop:stop,toDisplayString:toDisplayString,toHandlerKey:f,toHandlers:toHandlers,toRaw:toRaw,toRef:toRef,toRefs:toRefs,toValue:toValue,transformVNodeArgs:transformVNodeArgs,triggerRef:triggerRef,unref:unref,useAttrs:useAttrs,useCssModule:useCssModule,useCssVars:useCssVars,useModel:useModel,useSSRContext:useSSRContext,useSlots:useSlots,useTransitionState:useTransitionState,vModelCheckbox:Ln,vModelDynamic:Bn,vModelRadio:Hn,vModelSelect:jn,vModelText:Dn,vShow:vn,version:Jt,warn:Yt,watch:watch,watchEffect:watchEffect,watchPostEffect:watchPostEffect,watchSyncEffect:watchSyncEffect,withAsyncContext:withAsyncContext,withCtx:withCtx,withDefaults:withDefaults,withDirectives:withDirectives,withKeys:withKeys,withMemo:withMemo,withModifiers:withModifiers,withScopeId:withScopeId});function initDev(){console.info("You are running a development build of Vue.\nMake sure to use the production build (*.prod.js) when deploying for production.");initCustomFormatter()}const Xn=Symbol("Fragment");const Qn=Symbol("Teleport");const Zn=Symbol("Suspense");const eo=Symbol("KeepAlive");const to=Symbol("BaseTransition");const no=Symbol("openBlock");const oo=Symbol("createBlock");const ro=Symbol("createElementBlock");const so=Symbol("createVNode");const io=Symbol("createElementVNode");const ao=Symbol("createCommentVNode");const co=Symbol("createTextVNode");const lo=Symbol("createStaticVNode");const uo=Symbol("resolveComponent");const po=Symbol("resolveDynamicComponent");const fo=Symbol("resolveDirective");const ho=Symbol("resolveFilter");const mo=Symbol("withDirectives");const go=Symbol("renderList");const yo=Symbol("renderSlot");const vo=Symbol("createSlots");const bo=Symbol("toDisplayString");const Co=Symbol("mergeProps");const So=Symbol("normalizeClass");const xo=Symbol("normalizeStyle");const wo=Symbol("normalizeProps");const Eo=Symbol("guardReactiveProps");const ko=Symbol("toHandlers");const _o=Symbol("camelize");const To=Symbol("capitalize");const No=Symbol("toHandlerKey");const Ro=Symbol("setBlockTracking");const Ao=Symbol("pushScopeId");const $o=Symbol("popScopeId");const Oo=Symbol("withCtx");const Io=Symbol("unref");const Po=Symbol("isRef");const Vo=Symbol("withMemo");const Mo=Symbol("isMemoSame");const Fo={[Xn]:"Fragment",[Qn]:"Teleport",[Zn]:"Suspense",[eo]:"KeepAlive",[to]:"BaseTransition",[no]:"openBlock",[oo]:"createBlock",[ro]:"createElementBlock",[so]:"createVNode",[io]:"createElementVNode",[ao]:"createCommentVNode",[co]:"createTextVNode",[lo]:"createStaticVNode",[uo]:"resolveComponent",[po]:"resolveDynamicComponent",[fo]:"resolveDirective",[ho]:"resolveFilter",[mo]:"withDirectives",[go]:"renderList",[yo]:"renderSlot",[vo]:"createSlots",[bo]:"toDisplayString",[Co]:"mergeProps",[So]:"normalizeClass",[xo]:"normalizeStyle",[wo]:"normalizeProps",[Eo]:"guardReactiveProps",[ko]:"toHandlers",[_o]:"camelize",[To]:"capitalize",[No]:"toHandlerKey",[Ro]:"setBlockTracking",[Ao]:"pushScopeId",[$o]:"popScopeId",[Oo]:"withCtx",[Io]:"unref",[Po]:"isRef",[Vo]:"withMemo",[Mo]:"isMemoSame"};function registerRuntimeHelpers(e){Object.getOwnPropertySymbols(e).forEach((t=>{Fo[t]=e[t]}))}const Do={start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0},source:""};function createRoot(e,t=""){return{type:0,source:t,children:e,helpers:new Set,components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:void 0,loc:Do}}function createVNodeCall(e,t,n,o,r,s,i,a=false,c=false,l=false,u=Do){if(e){if(a){e.helper(no);e.helper(getVNodeBlockHelper(e.inSSR,l))}else e.helper(getVNodeHelper(e.inSSR,l));i&&e.helper(mo)}return{type:13,tag:t,props:n,children:o,patchFlag:r,dynamicProps:s,directives:i,isBlock:a,disableTracking:c,isComponent:l,loc:u}}function createArrayExpression(e,t=Do){return{type:17,loc:t,elements:e}}function createObjectExpression(e,t=Do){return{type:15,loc:t,properties:e}}function createObjectProperty(e,t){return{type:16,loc:Do,key:isString(e)?createSimpleExpression(e,true):e,value:t}}function createSimpleExpression(e,t=false,n=Do,o=0){return{type:4,loc:n,content:e,isStatic:t,constType:t?3:o}}function createCompoundExpression(e,t=Do){return{type:8,loc:t,children:e}}function createCallExpression(e,t=[],n=Do){return{type:14,loc:n,callee:e,arguments:t}}function createFunctionExpression(e,t=void 0,n=false,o=false,r=Do){return{type:18,params:e,returns:t,newline:n,isSlot:o,loc:r}}function createConditionalExpression(e,t,n,o=true){return{type:19,test:e,consequent:t,alternate:n,newline:o,loc:Do}}function createCacheExpression(e,t,n=false){return{type:20,index:e,value:t,isVNode:n,loc:Do}}function createBlockStatement(e){return{type:21,body:e,loc:Do}}function getVNodeHelper(e,t){return e||t?so:io}function getVNodeBlockHelper(e,t){return e||t?oo:ro}function convertToBlock(e,{helper:t,removeHelper:n,inSSR:o}){if(!e.isBlock){e.isBlock=true;n(getVNodeHelper(o,e.isComponent));t(no);t(getVNodeBlockHelper(o,e.isComponent))}}const Lo=new Uint8Array([123,123]);const Ho=new Uint8Array([125,125]);function isTagStartChar(e){return e>=97&&e<=122||e>=65&&e<=90}function isWhitespace(e){return e===32||e===10||e===9||e===12||e===13}function isEndOfTagSection(e){return e===47||e===62||isWhitespace(e)}function toCharCodes(e){const t=new Uint8Array(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}const jo={Cdata:new Uint8Array([67,68,65,84,65,91]),CdataEnd:new Uint8Array([93,93,62]),CommentEnd:new Uint8Array([45,45,62]),ScriptEnd:new Uint8Array([60,47,115,99,114,105,112,116]),StyleEnd:new Uint8Array([60,47,115,116,121,108,101]),TitleEnd:new Uint8Array([60,47,116,105,116,108,101]),TextareaEnd:new Uint8Array([60,47,116,101,120,116,97,114,101,97])};class Tokenizer{constructor(e,t){this.stack=e;this.cbs=t;this.state=1;this.buffer="";this.sectionStart=0;this.index=0;this.entityStart=0;this.baseState=1;this.inRCDATA=false;this.inXML=false;this.inVPre=false;this.newlines=[];this.mode=0;this.delimiterOpen=Lo;this.delimiterClose=Ho;this.delimiterIndex=-1;this.currentSequence=void 0;this.sequenceIndex=0}get inSFCRoot(){return this.mode===2&&this.stack.length===0}reset(){this.state=1;this.mode=0;this.buffer="";this.sectionStart=0;this.index=0;this.baseState=1;this.inRCDATA=false;this.currentSequence=void 0;this.newlines.length=0;this.delimiterOpen=Lo;this.delimiterClose=Ho}getPos(e){let t=1;let n=e+1;for(let o=this.newlines.length-1;o>=0;o--){const r=this.newlines[o];if(e>r){t=o+2;n=e-r;break}}return{column:n,line:t,offset:e}}peek(){return this.buffer.charCodeAt(this.index+1)}stateText(e){if(e===60){this.index>this.sectionStart&&this.cbs.ontext(this.sectionStart,this.index);this.state=5;this.sectionStart=this.index}else if(!this.inVPre&&e===this.delimiterOpen[0]){this.state=2;this.delimiterIndex=0;this.stateInterpolationOpen(e)}}stateInterpolationOpen(e){if(e===this.delimiterOpen[this.delimiterIndex])if(this.delimiterIndex===this.delimiterOpen.length-1){const e=this.index+1-this.delimiterOpen.length;e>this.sectionStart&&this.cbs.ontext(this.sectionStart,e);this.state=3;this.sectionStart=e}else this.delimiterIndex++;else if(this.inRCDATA){this.state=32;this.stateInRCDATA(e)}else{this.state=1;this.stateText(e)}}stateInterpolation(e){if(e===this.delimiterClose[0]){this.state=4;this.delimiterIndex=0;this.stateInterpolationClose(e)}}stateInterpolationClose(e){if(e===this.delimiterClose[this.delimiterIndex])if(this.delimiterIndex===this.delimiterClose.length-1){this.cbs.oninterpolation(this.sectionStart,this.index+1);this.inRCDATA?this.state=32:this.state=1;this.sectionStart=this.index+1}else this.delimiterIndex++;else{this.state=3;this.stateInterpolation(e)}}stateSpecialStartSequence(e){const t=this.sequenceIndex===this.currentSequence.length;const n=t?isEndOfTagSection(e):(e|32)===this.currentSequence[this.sequenceIndex];if(n){if(!t){this.sequenceIndex++;return}}else this.inRCDATA=false;this.sequenceIndex=0;this.state=6;this.stateInTagName(e)}stateInRCDATA(e){if(this.sequenceIndex===this.currentSequence.length){if(e===62||isWhitespace(e)){const t=this.index-this.currentSequence.length;if(this.sectionStart<t){const e=this.index;this.index=t;this.cbs.ontext(this.sectionStart,t);this.index=e}this.sectionStart=t+2;this.stateInClosingTagName(e);this.inRCDATA=false;return}this.sequenceIndex=0}if((e|32)===this.currentSequence[this.sequenceIndex])this.sequenceIndex+=1;else if(this.sequenceIndex===0)if(this.currentSequence===jo.TitleEnd||this.currentSequence===jo.TextareaEnd&&!this.inSFCRoot){if(e===this.delimiterOpen[0]){this.state=2;this.delimiterIndex=0;this.stateInterpolationOpen(e)}}else this.fastForwardTo(60)&&(this.sequenceIndex=1);else this.sequenceIndex=Number(e===60)}stateCDATASequence(e){if(e===jo.Cdata[this.sequenceIndex]){if(++this.sequenceIndex===jo.Cdata.length){this.state=28;this.currentSequence=jo.CdataEnd;this.sequenceIndex=0;this.sectionStart=this.index+1}}else{this.sequenceIndex=0;this.state=23;this.stateInDeclaration(e)}}
/**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */fastForwardTo(e){while(++this.index<this.buffer.length){const t=this.buffer.charCodeAt(this.index);t===10&&this.newlines.push(this.index);if(t===e)return true}this.index=this.buffer.length-1;return false}stateInCommentLike(e){if(e===this.currentSequence[this.sequenceIndex]){if(++this.sequenceIndex===this.currentSequence.length){this.currentSequence===jo.CdataEnd?this.cbs.oncdata(this.sectionStart,this.index-2):this.cbs.oncomment(this.sectionStart,this.index-2);this.sequenceIndex=0;this.sectionStart=this.index+1;this.state=1}}else this.sequenceIndex===0?this.fastForwardTo(this.currentSequence[0])&&(this.sequenceIndex=1):e!==this.currentSequence[this.sequenceIndex-1]&&(this.sequenceIndex=0)}startSpecial(e,t){this.enterRCDATA(e,t);this.state=31}enterRCDATA(e,t){this.inRCDATA=true;this.currentSequence=e;this.sequenceIndex=t}stateBeforeTagName(e){if(e===33){this.state=22;this.sectionStart=this.index+1}else if(e===63){this.state=24;this.sectionStart=this.index+1}else if(isTagStartChar(e)){this.sectionStart=this.index;this.mode===0?this.state=6:this.inSFCRoot?this.state=34:this.inXML?this.state=6:this.state=e===116?30:e===115?29:6}else if(e===47)this.state=8;else{this.state=1;this.stateText(e)}}stateInTagName(e){isEndOfTagSection(e)&&this.handleTagName(e)}stateInSFCRootTagName(e){if(isEndOfTagSection(e)){const t=this.buffer.slice(this.sectionStart,this.index);t!=="template"&&this.enterRCDATA(toCharCodes("</"+t),0);this.handleTagName(e)}}handleTagName(e){this.cbs.onopentagname(this.sectionStart,this.index);this.sectionStart=-1;this.state=11;this.stateBeforeAttrName(e)}stateBeforeClosingTagName(e){if(isWhitespace(e));else if(e===62){this.cbs.onerr(14,this.index);this.state=1;this.sectionStart=this.index+1}else{this.state=isTagStartChar(e)?9:27;this.sectionStart=this.index}}stateInClosingTagName(e){if(e===62||isWhitespace(e)){this.cbs.onclosetag(this.sectionStart,this.index);this.sectionStart=-1;this.state=10;this.stateAfterClosingTagName(e)}}stateAfterClosingTagName(e){if(e===62){this.state=1;this.sectionStart=this.index+1}}stateBeforeAttrName(e){if(e===62){this.cbs.onopentagend(this.index);this.inRCDATA?this.state=32:this.state=1;this.sectionStart=this.index+1}else if(e===47){this.state=7;this.peek()!==62&&this.cbs.onerr(22,this.index)}else if(e===60&&this.peek()===47){this.cbs.onopentagend(this.index);this.state=5;this.sectionStart=this.index}else if(!isWhitespace(e)){e===61&&this.cbs.onerr(19,this.index);this.handleAttrStart(e)}}handleAttrStart(e){if(e===118&&this.peek()===45){this.state=13;this.sectionStart=this.index}else if(e===46||e===58||e===64||e===35){this.cbs.ondirname(this.index,this.index+1);this.state=14;this.sectionStart=this.index+1}else{this.state=12;this.sectionStart=this.index}}stateInSelfClosingTag(e){if(e===62){this.cbs.onselfclosingtag(this.index);this.state=1;this.sectionStart=this.index+1;this.inRCDATA=false}else if(!isWhitespace(e)){this.state=11;this.stateBeforeAttrName(e)}}stateInAttrName(e){if(e===61||isEndOfTagSection(e)){this.cbs.onattribname(this.sectionStart,this.index);this.handleAttrNameEnd(e)}else e!==34&&e!==39&&e!==60||this.cbs.onerr(17,this.index)}stateInDirName(e){if(e===61||isEndOfTagSection(e)){this.cbs.ondirname(this.sectionStart,this.index);this.handleAttrNameEnd(e)}else if(e===58){this.cbs.ondirname(this.sectionStart,this.index);this.state=14;this.sectionStart=this.index+1}else if(e===46){this.cbs.ondirname(this.sectionStart,this.index);this.state=16;this.sectionStart=this.index+1}}stateInDirArg(e){if(e===61||isEndOfTagSection(e)){this.cbs.ondirarg(this.sectionStart,this.index);this.handleAttrNameEnd(e)}else if(e===91)this.state=15;else if(e===46){this.cbs.ondirarg(this.sectionStart,this.index);this.state=16;this.sectionStart=this.index+1}}stateInDynamicDirArg(e){if(e===93)this.state=14;else if(e===61||isEndOfTagSection(e)){this.cbs.ondirarg(this.sectionStart,this.index+1);this.handleAttrNameEnd(e);this.cbs.onerr(27,this.index)}}stateInDirModifier(e){if(e===61||isEndOfTagSection(e)){this.cbs.ondirmodifier(this.sectionStart,this.index);this.handleAttrNameEnd(e)}else if(e===46){this.cbs.ondirmodifier(this.sectionStart,this.index);this.sectionStart=this.index+1}}handleAttrNameEnd(e){this.sectionStart=this.index;this.state=17;this.cbs.onattribnameend(this.index);this.stateAfterAttrName(e)}stateAfterAttrName(e){if(e===61)this.state=18;else if(e===47||e===62){this.cbs.onattribend(0,this.sectionStart);this.sectionStart=-1;this.state=11;this.stateBeforeAttrName(e)}else if(!isWhitespace(e)){this.cbs.onattribend(0,this.sectionStart);this.handleAttrStart(e)}}stateBeforeAttrValue(e){if(e===34){this.state=19;this.sectionStart=this.index+1}else if(e===39){this.state=20;this.sectionStart=this.index+1}else if(!isWhitespace(e)){this.sectionStart=this.index;this.state=21;this.stateInAttrValueNoQuotes(e)}}handleInAttrValue(e,t){if(e===t||this.fastForwardTo(t)){this.cbs.onattribdata(this.sectionStart,this.index);this.sectionStart=-1;this.cbs.onattribend(t===34?3:2,this.index+1);this.state=11}}stateInAttrValueDoubleQuotes(e){this.handleInAttrValue(e,34)}stateInAttrValueSingleQuotes(e){this.handleInAttrValue(e,39)}stateInAttrValueNoQuotes(e){if(isWhitespace(e)||e===62){this.cbs.onattribdata(this.sectionStart,this.index);this.sectionStart=-1;this.cbs.onattribend(1,this.index);this.state=11;this.stateBeforeAttrName(e)}else e!==34&&e!==39&&e!==60&&e!==61&&e!==96||this.cbs.onerr(18,this.index)}stateBeforeDeclaration(e){if(e===91){this.state=26;this.sequenceIndex=0}else this.state=e===45?25:23}stateInDeclaration(e){if(e===62||this.fastForwardTo(62)){this.state=1;this.sectionStart=this.index+1}}stateInProcessingInstruction(e){if(e===62||this.fastForwardTo(62)){this.cbs.onprocessinginstruction(this.sectionStart,this.index);this.state=1;this.sectionStart=this.index+1}}stateBeforeComment(e){if(e===45){this.state=28;this.currentSequence=jo.CommentEnd;this.sequenceIndex=2;this.sectionStart=this.index+1}else this.state=23}stateInSpecialComment(e){if(e===62||this.fastForwardTo(62)){this.cbs.oncomment(this.sectionStart,this.index);this.state=1;this.sectionStart=this.index+1}}stateBeforeSpecialS(e){if(e===jo.ScriptEnd[3])this.startSpecial(jo.ScriptEnd,4);else if(e===jo.StyleEnd[3])this.startSpecial(jo.StyleEnd,4);else{this.state=6;this.stateInTagName(e)}}stateBeforeSpecialT(e){if(e===jo.TitleEnd[3])this.startSpecial(jo.TitleEnd,4);else if(e===jo.TextareaEnd[3])this.startSpecial(jo.TextareaEnd,4);else{this.state=6;this.stateInTagName(e)}}startEntity(){}stateInEntity(){}parse(e){this.buffer=e;while(this.index<this.buffer.length){const e=this.buffer.charCodeAt(this.index);e===10&&this.newlines.push(this.index);switch(this.state){case 1:this.stateText(e);break;case 2:this.stateInterpolationOpen(e);break;case 3:this.stateInterpolation(e);break;case 4:this.stateInterpolationClose(e);break;case 31:this.stateSpecialStartSequence(e);break;case 32:this.stateInRCDATA(e);break;case 26:this.stateCDATASequence(e);break;case 19:this.stateInAttrValueDoubleQuotes(e);break;case 12:this.stateInAttrName(e);break;case 13:this.stateInDirName(e);break;case 14:this.stateInDirArg(e);break;case 15:this.stateInDynamicDirArg(e);break;case 16:this.stateInDirModifier(e);break;case 28:this.stateInCommentLike(e);break;case 27:this.stateInSpecialComment(e);break;case 11:this.stateBeforeAttrName(e);break;case 6:this.stateInTagName(e);break;case 34:this.stateInSFCRootTagName(e);break;case 9:this.stateInClosingTagName(e);break;case 5:this.stateBeforeTagName(e);break;case 17:this.stateAfterAttrName(e);break;case 20:this.stateInAttrValueSingleQuotes(e);break;case 18:this.stateBeforeAttrValue(e);break;case 8:this.stateBeforeClosingTagName(e);break;case 10:this.stateAfterClosingTagName(e);break;case 29:this.stateBeforeSpecialS(e);break;case 30:this.stateBeforeSpecialT(e);break;case 21:this.stateInAttrValueNoQuotes(e);break;case 7:this.stateInSelfClosingTag(e);break;case 23:this.stateInDeclaration(e);break;case 22:this.stateBeforeDeclaration(e);break;case 25:this.stateBeforeComment(e);break;case 24:this.stateInProcessingInstruction(e);break;case 33:this.stateInEntity();break}this.index++}this.cleanup();this.finish()}cleanup(){if(this.sectionStart!==this.index)if(this.state===1||this.state===32&&this.sequenceIndex===0){this.cbs.ontext(this.sectionStart,this.index);this.sectionStart=this.index}else if(this.state===19||this.state===20||this.state===21){this.cbs.onattribdata(this.sectionStart,this.index);this.sectionStart=this.index}}finish(){this.handleTrailingData();this.cbs.onend()}handleTrailingData(){const e=this.buffer.length;this.sectionStart>=e||(this.state===28?this.currentSequence===jo.CdataEnd?this.cbs.oncdata(this.sectionStart,e):this.cbs.oncomment(this.sectionStart,e):this.state===6||this.state===11||this.state===18||this.state===17||this.state===12||this.state===13||this.state===14||this.state===15||this.state===16||this.state===20||this.state===19||this.state===21||this.state===9||this.cbs.ontext(this.sectionStart,e))}emitCodePoint(e,t){}}function defaultOnError(e){throw e}function defaultOnWarn(e){console.warn(`[Vue warn] ${e.message}`)}function createCompilerError(e,t,n,o){const r=(n||Bo)[e]+(o||"");const s=new SyntaxError(String(r));s.code=e;s.loc=t;return s}const Bo={0:"Illegal comment.",1:"CDATA section is allowed only in XML context.",2:"Duplicate attribute.",3:"End tag cannot have attributes.",4:"Illegal '/' in tags.",5:"Unexpected EOF in tag.",6:"Unexpected EOF in CDATA section.",7:"Unexpected EOF in comment.",8:"Unexpected EOF in script.",9:"Unexpected EOF in tag.",10:"Incorrectly closed comment.",11:"Incorrectly opened comment.",12:"Illegal tag name. Use '&lt;' to print '<'.",13:"Attribute value was expected.",14:"End tag name was expected.",15:"Whitespace was expected.",16:"Unexpected '\x3c!--' in comment.",17:"Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).",18:"Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",19:"Attribute name cannot start with '='.",21:"'<?' is allowed only in XML context.",20:"Unexpected null character.",22:"Illegal '/' in tags.",23:"Invalid end tag.",24:"Element is missing end tag.",25:"Interpolation end sign was not found.",27:"End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",26:"Legal directive name was expected.",28:"v-if/v-else-if is missing expression.",29:"v-if/else branches must use unique keys.",30:"v-else/v-else-if has no adjacent v-if or v-else-if.",31:"v-for is missing expression.",32:"v-for has invalid expression.",33:"<template v-for> key should be placed on the <template> tag.",34:"v-bind is missing expression.",52:"v-bind with same-name shorthand only allows static argument.",35:"v-on is missing expression.",36:"Unexpected custom directive on <slot> outlet.",37:"Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",38:"Duplicate slot names found. ",39:"Extraneous children found when component already has explicitly named default slot. These children will be ignored.",40:"v-slot can only be used on components or <template> tags.",41:"v-model is missing expression.",42:"v-model value must be a valid JavaScript member expression.",43:"v-model cannot be used on v-for or v-slot scope variables because they are not writable.",44:"v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.",45:"Error parsing JavaScript expression: ",46:"<KeepAlive> expects exactly one child component.",51:"@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.",47:'"prefixIdentifiers" option is not supported in this build of compiler.',48:"ES module mode is not supported in this build of compiler.",49:'"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',50:'"scopeId" option is only supported in module mode.',53:""};const isStaticExp=e=>e.type===4&&e.isStatic;function isCoreComponent(e){switch(e){case"Teleport":case"teleport":return Qn;case"Suspense":case"suspense":return Zn;case"KeepAlive":case"keep-alive":return eo;case"BaseTransition":case"base-transition":return to}}const Uo=/^\d|[^\$\w]/;const isSimpleIdentifier=e=>!Uo.test(e);const zo=/[A-Za-z_$\xA0-\uFFFF]/;const Wo=/[\.\?\w$\xA0-\uFFFF]/;const qo=/\s+[.[]\s*|\s*[.[]\s+/g;const isMemberExpressionBrowser=e=>{e=e.trim().replace(qo,(e=>e.trim()));let t=0;let n=[];let o=0;let r=0;let s=null;for(let i=0;i<e.length;i++){const a=e.charAt(i);switch(t){case 0:if(a==="["){n.push(t);t=1;o++}else if(a==="("){n.push(t);t=2;r++}else if(!(i===0?zo:Wo).test(a))return false;break;case 1:if(a==="'"||a==='"'||a==="`"){n.push(t);t=3;s=a}else a==="["?o++:a==="]"&&(--o||(t=n.pop()));break;case 2:if(a==="'"||a==='"'||a==="`"){n.push(t);t=3;s=a}else if(a==="(")r++;else if(a===")"){if(i===e.length-1)return false;--r||(t=n.pop())}break;case 3:if(a===s){t=n.pop();s=null}break}}return!o&&!r};const Ko=isMemberExpressionBrowser;function assert(e,t){if(!e)throw new Error(t||"unexpected compiler condition")}function findDir(e,t,n=false){for(let o=0;o<e.props.length;o++){const r=e.props[o];if(r.type===7&&(n||r.exp)&&(isString(t)?r.name===t:t.test(r.name)))return r}}function findProp(e,t,n=false,o=false){for(let r=0;r<e.props.length;r++){const s=e.props[r];if(s.type===6){if(n)continue;if(s.name===t&&(s.value||o))return s}else if(s.name==="bind"&&(s.exp||o)&&isStaticArgOf(s.arg,t))return s}}function isStaticArgOf(e,t){return!!(e&&isStaticExp(e)&&e.content===t)}function hasDynamicKeyVBind(e){return e.props.some((e=>e.type===7&&e.name==="bind"&&(!e.arg||e.arg.type!==4||!e.arg.isStatic)))}function isText$1(e){return e.type===5||e.type===2}function isVSlot(e){return e.type===7&&e.name==="slot"}function isTemplateNode(e){return e.type===1&&e.tagType===3}function isSlotOutlet(e){return e.type===1&&e.tagType===2}const Go=new Set([wo,Eo]);function getUnnormalizedProps(e,t=[]){if(e&&!isString(e)&&e.type===14){const n=e.callee;if(!isString(n)&&Go.has(n))return getUnnormalizedProps(e.arguments[0],t.concat(e))}return[e,t]}function injectProp(e,t,n){let o;let r=e.type===13?e.props:e.arguments[2];let s=[];let i;if(r&&!isString(r)&&r.type===14){const e=getUnnormalizedProps(r);r=e[0];s=e[1];i=s[s.length-1]}if(r==null||isString(r))o=createObjectExpression([t]);else if(r.type===14){const e=r.arguments[0];isString(e)||e.type!==15?r.callee===ko?o=createCallExpression(n.helper(Co),[createObjectExpression([t]),r]):r.arguments.unshift(createObjectExpression([t])):hasProp(t,e)||e.properties.unshift(t);!o&&(o=r)}else if(r.type===15){hasProp(t,r)||r.properties.unshift(t);o=r}else{o=createCallExpression(n.helper(Co),[createObjectExpression([t]),r]);i&&i.callee===Eo&&(i=s[s.length-2])}e.type===13?i?i.arguments[0]=o:e.props=o:i?i.arguments[0]=o:e.arguments[2]=o}function hasProp(e,t){let n=false;if(e.key.type===4){const o=e.key.content;n=t.properties.some((e=>e.key.type===4&&e.key.content===o))}return n}function toValidAssetId(e,t){return`_${t}_${e.replace(/[^\w]/g,((t,n)=>t==="-"?"_":e.charCodeAt(n).toString()))}`}function getMemoedVNodeCall(e){return e.type===14&&e.callee===Vo?e.arguments[1].returns:e}const Jo=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;const Yo={parseMode:"base",ns:0,delimiters:["{{","}}"],getNamespace:()=>0,isVoidTag:NO,isPreTag:NO,isCustomElement:NO,onError:defaultOnError,onWarn:defaultOnWarn,comments:true,prefixIdentifiers:false};let Xo=Yo;let Qo=null;let Zo="";let er=null;let tr=null;let nr="";let or=-1;let rr=-1;let sr=0;let ir=false;let ar=null;const cr=[];const lr=new Tokenizer(cr,{onerr:emitError,ontext(e,t){onText(getSlice(e,t),e,t)},ontextentity(e,t,n){onText(e,t,n)},oninterpolation(e,t){if(ir)return onText(getSlice(e,t),e,t);let n=e+lr.delimiterOpen.length;let o=t-lr.delimiterClose.length;while(isWhitespace(Zo.charCodeAt(n)))n++;while(isWhitespace(Zo.charCodeAt(o-1)))o--;let r=getSlice(n,o);r.includes("&")&&(r=Xo.decodeEntities(r,false));addNode({type:5,content:createExp(r,false,getLoc(n,o)),loc:getLoc(e,t)})},onopentagname(e,t){const n=getSlice(e,t);er={type:1,tag:n,ns:Xo.getNamespace(n,cr[0],Xo.ns),tagType:0,props:[],children:[],loc:getLoc(e-1,t),codegenNode:void 0}},onopentagend(e){endOpenTag(e)},onclosetag(e,t){const n=getSlice(e,t);if(!Xo.isVoidTag(n)){let o=false;for(let e=0;e<cr.length;e++){const r=cr[e];if(r.tag.toLowerCase()===n.toLowerCase()){o=true;e>0&&emitError(24,cr[0].loc.start.offset);for(let n=0;n<=e;n++){const o=cr.shift();onCloseTag(o,t,n<e)}break}}o||emitError(23,backTrack(e,60))}},onselfclosingtag(e){var t;const n=er.tag;er.isSelfClosing=true;endOpenTag(e);((t=cr[0])==null?void 0:t.tag)===n&&onCloseTag(cr.shift(),e)},onattribname(e,t){tr={type:6,name:getSlice(e,t),nameLoc:getLoc(e,t),value:void 0,loc:getLoc(e)}},ondirname(e,t){const n=getSlice(e,t);const o=n==="."||n===":"?"bind":n==="@"?"on":n==="#"?"slot":n.slice(2);ir||o!==""||emitError(26,e);if(ir||o==="")tr={type:6,name:n,nameLoc:getLoc(e,t),value:void 0,loc:getLoc(e)};else{tr={type:7,name:o,rawName:n,exp:void 0,arg:void 0,modifiers:n==="."?["prop"]:[],loc:getLoc(e)};if(o==="pre"){ir=lr.inVPre=true;ar=er;const e=er.props;for(let t=0;t<e.length;t++)e[t].type===7&&(e[t]=dirToAttr(e[t]))}}},ondirarg(e,t){if(e===t)return;const n=getSlice(e,t);if(ir){tr.name+=n;setLocEnd(tr.nameLoc,t)}else{const o=n[0]!=="[";tr.arg=createExp(o?n:n.slice(1,-1),o,getLoc(e,t),o?3:0)}},ondirmodifier(e,t){const n=getSlice(e,t);if(ir){tr.name+="."+n;setLocEnd(tr.nameLoc,t)}else if(tr.name==="slot"){const e=tr.arg;if(e){e.content+="."+n;setLocEnd(e.loc,t)}}else tr.modifiers.push(n)},onattribdata(e,t){nr+=getSlice(e,t);or<0&&(or=e);rr=t},onattribentity(e,t,n){nr+=e;or<0&&(or=t);rr=n},onattribnameend(e){const t=tr.loc.start.offset;const n=getSlice(t,e);tr.type===7&&(tr.rawName=n);er.props.some((e=>(e.type===7?e.rawName:e.name)===n))&&emitError(2,t)},onattribend(e,t){if(er&&tr){setLocEnd(tr.loc,t);if(e!==0){nr.includes("&")&&(nr=Xo.decodeEntities(nr,true));if(tr.type===6){tr.name==="class"&&(nr=condense(nr).trim());e!==1||nr||emitError(13,t);tr.value={type:2,content:nr,loc:e===1?getLoc(or,rr):getLoc(or-1,rr+1)};lr.inSFCRoot&&er.tag==="template"&&tr.name==="lang"&&nr&&nr!=="html"&&lr.enterRCDATA(toCharCodes("</template"),0)}else{let e=0;tr.exp=createExp(nr,false,getLoc(or,rr),0,e);tr.name==="for"&&(tr.forParseResult=parseForExpression(tr.exp))}}tr.type===7&&tr.name==="pre"||er.props.push(tr)}nr="";or=rr=-1},oncomment(e,t){Xo.comments&&addNode({type:3,content:getSlice(e,t),loc:getLoc(e-4,t+3)})},onend(){const e=Zo.length;if(lr.state!==1)switch(lr.state){case 5:case 8:emitError(5,e);break;case 3:case 4:emitError(25,lr.sectionStart);break;case 28:lr.currentSequence===jo.CdataEnd?emitError(6,e):emitError(7,e);break;case 6:case 7:case 9:case 11:case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:case 20:case 21:emitError(9,e);break}for(let t=0;t<cr.length;t++){onCloseTag(cr[t],e-1);emitError(24,cr[t].loc.start.offset)}},oncdata(e,t){cr[0].ns!==0?onText(getSlice(e,t),e,t):emitError(1,e-9)},onprocessinginstruction(e){(cr[0]?cr[0].ns:Xo.ns)===0&&emitError(21,e-1)}});const ur=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/;const pr=/^\(|\)$/g;function parseForExpression(e){const t=e.loc;const n=e.content;const o=n.match(Jo);if(!o)return;const[,r,s]=o;const createAliasExpression=(e,n,o=false)=>{const r=t.start.offset+n;const s=r+e.length;return createExp(e,false,getLoc(r,s),0,o?1:0)};const i={source:createAliasExpression(s.trim(),n.indexOf(s,r.length)),value:void 0,key:void 0,index:void 0,finalized:false};let a=r.trim().replace(pr,"").trim();const c=r.indexOf(a);const l=a.match(ur);if(l){a=a.replace(ur,"").trim();const e=l[1].trim();let t;if(e){t=n.indexOf(e,c+a.length);i.key=createAliasExpression(e,t,true)}if(l[2]){const o=l[2].trim();o&&(i.index=createAliasExpression(o,n.indexOf(o,i.key?t+e.length:c+a.length),true))}}a&&(i.value=createAliasExpression(a,c,true));return i}function getSlice(e,t){return Zo.slice(e,t)}function endOpenTag(e){lr.inSFCRoot&&(er.innerLoc=getLoc(e+1,e+1));addNode(er);const{tag:t,ns:n}=er;n===0&&Xo.isPreTag(t)&&sr++;if(Xo.isVoidTag(t))onCloseTag(er,e);else{cr.unshift(er);n!==1&&n!==2||(lr.inXML=true)}er=null}function onText(e,t,n){var o;{const t=(o=cr[0])==null?void 0:o.tag;t!=="script"&&t!=="style"&&e.includes("&")&&(e=Xo.decodeEntities(e,false))}const r=cr[0]||Qo;const s=r.children[r.children.length-1];if((s==null?void 0:s.type)===2){s.content+=e;setLocEnd(s.loc,n)}else r.children.push({type:2,content:e,loc:getLoc(t,n)})}function onCloseTag(e,t,o=false){setLocEnd(e.loc,o?backTrack(t,60):lookAhead(t,62)+1);if(lr.inSFCRoot){e.children.length?e.innerLoc.end=n({},e.children[e.children.length-1].loc.end):e.innerLoc.end=n({},e.innerLoc.start);e.innerLoc.source=getSlice(e.innerLoc.start.offset,e.innerLoc.end.offset)}const{tag:r,ns:s}=e;ir||(r==="slot"?e.tagType=2:isFragmentTemplate(e)?e.tagType=3:isComponent(e)&&(e.tagType=1));lr.inRCDATA||(e.children=condenseWhitespace(e.children,e.tag));s===0&&Xo.isPreTag(r)&&sr--;if(ar===e){ir=lr.inVPre=false;ar=null}lr.inXML&&(cr[0]?cr[0].ns:Xo.ns)===0&&(lr.inXML=false)}function lookAhead(e,t){let n=e;while(Zo.charCodeAt(n)!==t&&n<Zo.length-1)n++;return n}function backTrack(e,t){let n=e;while(Zo.charCodeAt(n)!==t&&n>=0)n--;return n}const dr=new Set(["if","else","else-if","for","slot"]);function isFragmentTemplate({tag:e,props:t}){if(e==="template")for(let e=0;e<t.length;e++)if(t[e].type===7&&dr.has(t[e].name))return true;return false}function isComponent({tag:e,props:t}){var n;if(Xo.isCustomElement(e))return false;if(e==="component"||isUpperCase(e.charCodeAt(0))||isCoreComponent(e)||((n=Xo.isBuiltInComponent)==null?void 0:n.call(Xo,e))||Xo.isNativeTag&&!Xo.isNativeTag(e))return true;for(let e=0;e<t.length;e++){const n=t[e];if(n.type===6&&n.name==="is"&&n.value&&n.value.content.startsWith("vue:"))return true}return false}function isUpperCase(e){return e>64&&e<91}const fr=/\r\n/g;function condenseWhitespace(e,t){var n,o;const r=Xo.whitespace!=="preserve";let s=false;for(let t=0;t<e.length;t++){const i=e[t];if(i.type===2)if(sr)i.content=i.content.replace(fr,"\n");else if(isAllWhitespace(i.content)){const a=(n=e[t-1])==null?void 0:n.type;const c=(o=e[t+1])==null?void 0:o.type;if(!a||!c||r&&(a===3&&(c===3||c===1)||a===1&&(c===3||c===1&&hasNewlineChar(i.content)))){s=true;e[t]=null}else i.content=" "}else r&&(i.content=condense(i.content))}if(sr&&t&&Xo.isPreTag(t)){const t=e[0];t&&t.type===2&&(t.content=t.content.replace(/^\r?\n/,""))}return s?e.filter(Boolean):e}function isAllWhitespace(e){for(let t=0;t<e.length;t++)if(!isWhitespace(e.charCodeAt(t)))return false;return true}function hasNewlineChar(e){for(let t=0;t<e.length;t++){const n=e.charCodeAt(t);if(n===10||n===13)return true}return false}function condense(e){let t="";let n=false;for(let o=0;o<e.length;o++)if(isWhitespace(e.charCodeAt(o))){if(!n){t+=" ";n=true}}else{t+=e[o];n=false}return t}function addNode(e){(cr[0]||Qo).children.push(e)}function getLoc(e,t){return{start:lr.getPos(e),end:t==null?t:lr.getPos(t),source:t==null?t:getSlice(e,t)}}function setLocEnd(e,t){e.end=lr.getPos(t);e.source=getSlice(e.start.offset,t)}function dirToAttr(e){const t={type:6,name:e.rawName,nameLoc:getLoc(e.loc.start.offset,e.loc.start.offset+e.rawName.length),value:void 0,loc:e.loc};if(e.exp){const n=e.exp.loc;if(n.end.offset<e.loc.end.offset){n.start.offset--;n.start.column--;n.end.offset++;n.end.column++}t.value={type:2,content:e.exp.content,loc:n}}return t}function createExp(e,t=false,n,o=0,r=0){const s=createSimpleExpression(e,t,n,o);return s}function emitError(e,t,n){Xo.onError(createCompilerError(e,getLoc(t,t),void 0,n))}function reset(){lr.reset();er=null;tr=null;nr="";or=-1;rr=-1;cr.length=0}function baseParse(e,t){reset();Zo=e;Xo=n({},Yo);if(t){let e;for(e in t)t[e]!=null&&(Xo[e]=t[e])}if(!Xo.decodeEntities)throw new Error("[@vue/compiler-core] decodeEntities option is required in browser builds.");lr.mode=Xo.parseMode==="html"?1:Xo.parseMode==="sfc"?2:0;lr.inXML=Xo.ns===1||Xo.ns===2;const o=t==null?void 0:t.delimiters;if(o){lr.delimiterOpen=toCharCodes(o[0]);lr.delimiterClose=toCharCodes(o[1])}const r=Qo=createRoot([],e);lr.parse(Zo);r.loc=getLoc(0,e.length);r.children=condenseWhitespace(r.children);Qo=null;return r}function hoistStatic(e,t){walk(e,t,isSingleElementRoot(e,e.children[0]))}function isSingleElementRoot(e,t){const{children:n}=e;return n.length===1&&t.type===1&&!isSlotOutlet(t)}function walk(e,t,n=false){const{children:o}=e;const s=o.length;let i=0;for(let e=0;e<o.length;e++){const r=o[e];if(r.type===1&&r.tagType===0){const e=n?0:getConstantType(r,t);if(e>0){if(e>=2){r.codegenNode.patchFlag="-1 /* HOISTED */";r.codegenNode=t.hoist(r.codegenNode);i++;continue}}else{const e=r.codegenNode;if(e.type===13){const n=getPatchFlag(e);if((!n||n===512||n===1)&&getGeneratedPropsConstantType(r,t)>=2){const n=getNodeProps(r);n&&(e.props=t.hoist(n))}e.dynamicProps&&(e.dynamicProps=t.hoist(e.dynamicProps))}}}if(r.type===1){const e=r.tagType===1;e&&t.scopes.vSlot++;walk(r,t);e&&t.scopes.vSlot--}else if(r.type===11)walk(r,t,r.children.length===1);else if(r.type===9)for(let e=0;e<r.branches.length;e++)walk(r.branches[e],t,r.branches[e].children.length===1)}i&&t.transformHoist&&t.transformHoist(o,t,e);if(i&&i===s&&e.type===1&&e.tagType===0&&e.codegenNode&&e.codegenNode.type===13&&r(e.codegenNode.children)){const n=t.hoist(createArrayExpression(e.codegenNode.children));t.hmr&&(n.content=`[...${n.content}]`);e.codegenNode.children=n}}function getConstantType(e,t){const{constantCache:n}=t;switch(e.type){case 1:if(e.tagType!==0)return 0;const o=n.get(e);if(o!==void 0)return o;const r=e.codegenNode;if(r.type!==13)return 0;if(r.isBlock&&e.tag!=="svg"&&e.tag!=="foreignObject")return 0;const s=getPatchFlag(r);if(s){n.set(e,0);return 0}{let o=3;const s=getGeneratedPropsConstantType(e,t);if(s===0){n.set(e,0);return 0}s<o&&(o=s);for(let r=0;r<e.children.length;r++){const s=getConstantType(e.children[r],t);if(s===0){n.set(e,0);return 0}s<o&&(o=s)}if(o>1)for(let r=0;r<e.props.length;r++){const s=e.props[r];if(s.type===7&&s.name==="bind"&&s.exp){const r=getConstantType(s.exp,t);if(r===0){n.set(e,0);return 0}r<o&&(o=r)}}if(r.isBlock){for(let t=0;t<e.props.length;t++){const o=e.props[t];if(o.type===7){n.set(e,0);return 0}}t.removeHelper(no);t.removeHelper(getVNodeBlockHelper(t.inSSR,r.isComponent));r.isBlock=false;t.helper(getVNodeHelper(t.inSSR,r.isComponent))}n.set(e,o);return o}case 2:case 3:return 3;case 9:case 11:case 10:return 0;case 5:case 12:return getConstantType(e.content,t);case 4:return e.constType;case 8:let i=3;for(let n=0;n<e.children.length;n++){const o=e.children[n];if(isString(o)||isSymbol(o))continue;const r=getConstantType(o,t);if(r===0)return 0;r<i&&(i=r)}return i;default:return 0}}const hr=new Set([So,xo,wo,Eo]);function getConstantTypeOfHelperCall(e,t){if(e.type===14&&!isString(e.callee)&&hr.has(e.callee)){const n=e.arguments[0];if(n.type===4)return getConstantType(n,t);if(n.type===14)return getConstantTypeOfHelperCall(n,t)}return 0}function getGeneratedPropsConstantType(e,t){let n=3;const o=getNodeProps(e);if(o&&o.type===15){const{properties:e}=o;for(let o=0;o<e.length;o++){const{key:r,value:s}=e[o];const i=getConstantType(r,t);if(i===0)return i;i<n&&(n=i);let a;a=s.type===4?getConstantType(s,t):s.type===14?getConstantTypeOfHelperCall(s,t):0;if(a===0)return a;a<n&&(n=a)}}return n}function getNodeProps(e){const t=e.codegenNode;if(t.type===13)return t.props}function getPatchFlag(e){const t=e.patchFlag;return t?parseInt(t,10):void 0}function createTransformContext(t,{filename:n="",prefixIdentifiers:o=false,hoistStatic:r=false,hmr:s=false,cacheHandlers:i=false,nodeTransforms:a=[],directiveTransforms:c={},transformHoist:u=null,isBuiltInComponent:p=NOOP,isCustomElement:f=NOOP,expressionPlugins:m=[],scopeId:g=null,slotted:y=true,ssr:v=false,inSSR:b=false,ssrCssVars:C="",bindingMetadata:S=e,inline:x=false,isTS:w=false,onError:E=defaultOnError,onWarn:k=defaultOnWarn,compatConfig:_}){const T=n.replace(/\?.*$/,"").match(/([^/\\]+)\.\w+$/);const N={filename:n,selfName:T&&d(l(T[1])),prefixIdentifiers:o,hoistStatic:r,hmr:s,cacheHandlers:i,nodeTransforms:a,directiveTransforms:c,transformHoist:u,isBuiltInComponent:p,isCustomElement:f,expressionPlugins:m,scopeId:g,slotted:y,ssr:v,inSSR:b,ssrCssVars:C,bindingMetadata:S,inline:x,isTS:w,onError:E,onWarn:k,compatConfig:_,root:t,helpers:new Map,components:new Set,directives:new Set,hoists:[],imports:[],constantCache:new WeakMap,temps:0,cached:0,identifiers:Object.create(null),scopes:{vFor:0,vSlot:0,vPre:0,vOnce:0},parent:null,currentNode:t,childIndex:0,inVOnce:false,helper(e){const t=N.helpers.get(e)||0;N.helpers.set(e,t+1);return e},removeHelper(e){const t=N.helpers.get(e);if(t){const n=t-1;n?N.helpers.set(e,n):N.helpers.delete(e)}},helperString(e){return`_${Fo[N.helper(e)]}`},replaceNode(e){if(!N.currentNode)throw new Error("Node being replaced is already removed.");if(!N.parent)throw new Error("Cannot replace root node.");N.parent.children[N.childIndex]=N.currentNode=e},removeNode(e){if(!N.parent)throw new Error("Cannot remove root node.");const t=N.parent.children;const n=e?t.indexOf(e):N.currentNode?N.childIndex:-1;if(n<0)throw new Error("node being removed is not a child of current parent");if(e&&e!==N.currentNode){if(N.childIndex>n){N.childIndex--;N.onNodeRemoved()}}else{N.currentNode=null;N.onNodeRemoved()}N.parent.children.splice(n,1)},onNodeRemoved:NOOP,addIdentifiers(e){},removeIdentifiers(e){},hoist(e){isString(e)&&(e=createSimpleExpression(e));N.hoists.push(e);const t=createSimpleExpression(`_hoisted_${N.hoists.length}`,false,e.loc,2);t.hoisted=e;return t},cache(e,t=false){return createCacheExpression(N.cached++,e,t)}};return N}function transform(e,t){const n=createTransformContext(e,t);traverseNode(e,n);t.hoistStatic&&hoistStatic(e,n);t.ssr||createRootCodegen(e,n);e.helpers=new Set([...n.helpers.keys()]);e.components=[...n.components];e.directives=[...n.directives];e.imports=n.imports;e.hoists=n.hoists;e.temps=n.temps;e.cached=n.cached;e.transformed=true}function createRootCodegen(e,t){const{helper:n}=t;const{children:o}=e;if(o.length===1){const n=o[0];if(isSingleElementRoot(e,n)&&n.codegenNode){const o=n.codegenNode;o.type===13&&convertToBlock(o,t);e.codegenNode=o}else e.codegenNode=n}else if(o.length>1){let r=64;let s=g[64];if(o.filter((e=>e.type!==3)).length===1){r|=2048;s+=`, ${g[2048]}`}e.codegenNode=createVNodeCall(t,n(Xn),void 0,e.children,r+` /* ${s} */`,void 0,void 0,true,void 0,false)}}function traverseChildren(e,t){let n=0;const nodeRemoved=()=>{n--};for(;n<e.children.length;n++){const o=e.children[n];if(!isString(o)){t.parent=e;t.childIndex=n;t.onNodeRemoved=nodeRemoved;traverseNode(o,t)}}}function traverseNode(e,t){t.currentNode=e;const{nodeTransforms:n}=t;const o=[];for(let s=0;s<n.length;s++){const i=n[s](e,t);i&&(r(i)?o.push(...i):o.push(i));if(!t.currentNode)return;e=t.currentNode}switch(e.type){case 3:t.ssr||t.helper(ao);break;case 5:t.ssr||t.helper(bo);break;case 9:for(let n=0;n<e.branches.length;n++)traverseNode(e.branches[n],t);break;case 10:case 11:case 1:case 0:traverseChildren(e,t);break}t.currentNode=e;let s=o.length;while(s--)o[s]()}function createStructuralDirectiveTransform(e,t){const n=isString(e)?t=>t===e:t=>e.test(t);return(e,o)=>{if(e.type===1){const{props:r}=e;if(e.tagType===3&&r.some(isVSlot))return;const s=[];for(let i=0;i<r.length;i++){const a=r[i];if(a.type===7&&n(a.name)){r.splice(i,1);i--;const n=t(e,a,o);n&&s.push(n)}}return s}}}const mr="/*#__PURE__*/";const aliasHelper=e=>`${Fo[e]}: _${Fo[e]}`;function createCodegenContext(e,{mode:t="function",prefixIdentifiers:n=t==="module",sourceMap:o=false,filename:r="template.vue.html",scopeId:s=null,optimizeImports:i=false,runtimeGlobalName:a="Vue",runtimeModuleName:c="vue",ssrRuntimeModuleName:l="vue/server-renderer",ssr:u=false,isTS:p=false,inSSR:d=false}){const f={mode:t,prefixIdentifiers:n,sourceMap:o,filename:r,scopeId:s,optimizeImports:i,runtimeGlobalName:a,runtimeModuleName:c,ssrRuntimeModuleName:l,ssr:u,isTS:p,inSSR:d,source:e.source,code:"",column:1,line:1,offset:0,indentLevel:0,pure:false,map:void 0,helper(e){return`_${Fo[e]}`},push(e,t=-2,n){f.code+=e},indent(){newline(++f.indentLevel)},deindent(e=false){e?--f.indentLevel:newline(--f.indentLevel)},newline(){newline(f.indentLevel)}};function newline(e){f.push("\n"+"  ".repeat(e),0)}return f}function generate(e,t={}){const n=createCodegenContext(e,t);t.onContextCreated&&t.onContextCreated(n);const{mode:o,push:r,prefixIdentifiers:s,indent:i,deindent:a,newline:c,scopeId:l,ssr:u}=n;const p=Array.from(e.helpers);const d=p.length>0;const f=!s&&o!=="module";const m=n;genFunctionPreamble(e,m);const g=u?"ssrRender":"render";const y=u?["_ctx","_push","_parent","_attrs"]:["_ctx","_cache"];const v=y.join(", ");r(`function ${g}(${v}) {`);i();if(f){r("with (_ctx) {");i();if(d){r(`const { ${p.map(aliasHelper).join(", ")} } = _Vue\n`,-1);c()}}if(e.components.length){genAssets(e.components,"component",n);(e.directives.length||e.temps>0)&&c()}if(e.directives.length){genAssets(e.directives,"directive",n);e.temps>0&&c()}if(e.temps>0){r("let ");for(let t=0;t<e.temps;t++)r(`${t>0?", ":""}_temp${t}`)}if(e.components.length||e.directives.length||e.temps){r("\n",0);c()}u||r("return ");e.codegenNode?genNode(e.codegenNode,n):r("null");if(f){a();r("}")}a();r("}");return{ast:e,code:n.code,preamble:"",map:n.map?n.map.toJSON():void 0}}function genFunctionPreamble(e,t){const{ssr:n,prefixIdentifiers:o,push:r,newline:s,runtimeModuleName:i,runtimeGlobalName:a,ssrRuntimeModuleName:c}=t;const l=a;const u=Array.from(e.helpers);if(u.length>0){r(`const _Vue = ${l}\n`,-1);if(e.hoists.length){const e=[so,io,ao,co,lo].filter((e=>u.includes(e))).map(aliasHelper).join(", ");r(`const { ${e} } = _Vue\n`,-1)}}genHoists(e.hoists,t);s();r("return ")}function genAssets(e,t,{helper:n,push:o,newline:r,isTS:s}){const i=n(t==="component"?uo:fo);for(let n=0;n<e.length;n++){let a=e[n];const c=a.endsWith("__self");c&&(a=a.slice(0,-6));o(`const ${toValidAssetId(a,t)} = ${i}(${JSON.stringify(a)}${c?", true":""})${s?"!":""}`);n<e.length-1&&r()}}function genHoists(e,t){if(!e.length)return;t.pure=true;const{push:n,newline:o,helper:r,scopeId:s,mode:i}=t;o();for(let r=0;r<e.length;r++){const s=e[r];if(s){n(`const _hoisted_${r+1} = `);genNode(s,t);o()}}t.pure=false}function isText(e){return isString(e)||e.type===4||e.type===2||e.type===5||e.type===8}function genNodeListAsArray(e,t){const n=e.length>3||e.some((e=>r(e)||!isText(e)));t.push("[");n&&t.indent();genNodeList(e,t,n);n&&t.deindent();t.push("]")}function genNodeList(e,t,n=false,o=true){const{push:s,newline:i}=t;for(let a=0;a<e.length;a++){const c=e[a];isString(c)?s(c,-3):r(c)?genNodeListAsArray(c,t):genNode(c,t);if(a<e.length-1)if(n){o&&s(",");i()}else o&&s(", ")}}function genNode(e,t){if(isString(e))t.push(e,-3);else if(isSymbol(e))t.push(t.helper(e));else switch(e.type){case 1:case 9:case 11:assert(e.codegenNode!=null,"Codegen node is missing for element/if/for node. Apply appropriate transforms first.");genNode(e.codegenNode,t);break;case 2:genText(e,t);break;case 4:genExpression(e,t);break;case 5:genInterpolation(e,t);break;case 12:genNode(e.codegenNode,t);break;case 8:genCompoundExpression(e,t);break;case 3:genComment(e,t);break;case 13:genVNodeCall(e,t);break;case 14:genCallExpression(e,t);break;case 15:genObjectExpression(e,t);break;case 17:genArrayExpression(e,t);break;case 18:genFunctionExpression(e,t);break;case 19:genConditionalExpression(e,t);break;case 20:genCacheExpression(e,t);break;case 21:genNodeList(e.body,t,true,false);break;case 22:break;case 23:break;case 24:break;case 25:break;case 26:break;case 10:break;default:{assert(false,`unhandled codegen node type: ${e.type}`);const t=e;return t}}}function genText(e,t){t.push(JSON.stringify(e.content),-3,e)}function genExpression(e,t){const{content:n,isStatic:o}=e;t.push(o?JSON.stringify(n):n,-3,e)}function genInterpolation(e,t){const{push:n,helper:o,pure:r}=t;r&&n(mr);n(`${o(bo)}(`);genNode(e.content,t);n(")")}function genCompoundExpression(e,t){for(let n=0;n<e.children.length;n++){const o=e.children[n];isString(o)?t.push(o,-3):genNode(o,t)}}function genExpressionAsPropertyKey(e,t){const{push:n}=t;if(e.type===8){n("[");genCompoundExpression(e,t);n("]")}else if(e.isStatic){const t=isSimpleIdentifier(e.content)?e.content:JSON.stringify(e.content);n(t,-2,e)}else n(`[${e.content}]`,-3,e)}function genComment(e,t){const{push:n,helper:o,pure:r}=t;r&&n(mr);n(`${o(ao)}(${JSON.stringify(e.content)})`,-3,e)}function genVNodeCall(e,t){const{push:n,helper:o,pure:r}=t;const{tag:s,props:i,children:a,patchFlag:c,dynamicProps:l,directives:u,isBlock:p,disableTracking:d,isComponent:f}=e;u&&n(o(mo)+"(");p&&n(`(${o(no)}(${d?"true":""}), `);r&&n(mr);const m=p?getVNodeBlockHelper(t.inSSR,f):getVNodeHelper(t.inSSR,f);n(o(m)+"(",-2,e);genNodeList(genNullableArgs([s,i,a,c,l]),t);n(")");p&&n(")");if(u){n(", ");genNode(u,t);n(")")}}function genNullableArgs(e){let t=e.length;while(t--)if(e[t]!=null)break;return e.slice(0,t+1).map((e=>e||"null"))}function genCallExpression(e,t){const{push:n,helper:o,pure:r}=t;const s=isString(e.callee)?e.callee:o(e.callee);r&&n(mr);n(s+"(",-2,e);genNodeList(e.arguments,t);n(")")}function genObjectExpression(e,t){const{push:n,indent:o,deindent:r,newline:s}=t;const{properties:i}=e;if(!i.length){n("{}",-2,e);return}const a=i.length>1||i.some((e=>e.value.type!==4));n(a?"{":"{ ");a&&o();for(let e=0;e<i.length;e++){const{key:o,value:r}=i[e];genExpressionAsPropertyKey(o,t);n(": ");genNode(r,t);if(e<i.length-1){n(",");s()}}a&&r();n(a?"}":" }")}function genArrayExpression(e,t){genNodeListAsArray(e.elements,t)}function genFunctionExpression(e,t){const{push:n,indent:o,deindent:s}=t;const{params:i,returns:a,body:c,newline:l,isSlot:u}=e;u&&n(`_${Fo[Oo]}(`);n("(",-2,e);r(i)?genNodeList(i,t):i&&genNode(i,t);n(") => ");if(l||c){n("{");o()}if(a){l&&n("return ");r(a)?genNodeListAsArray(a,t):genNode(a,t)}else c&&genNode(c,t);if(l||c){s();n("}")}u&&n(")")}function genConditionalExpression(e,t){const{test:n,consequent:o,alternate:r,newline:s}=e;const{push:i,indent:a,deindent:c,newline:l}=t;if(n.type===4){const e=!isSimpleIdentifier(n.content);e&&i("(");genExpression(n,t);e&&i(")")}else{i("(");genNode(n,t);i(")")}s&&a();t.indentLevel++;s||i(" ");i("? ");genNode(o,t);t.indentLevel--;s&&l();s||i(" ");i(": ");const u=r.type===19;u||t.indentLevel++;genNode(r,t);u||t.indentLevel--;s&&c(true)}function genCacheExpression(e,t){const{push:n,helper:o,indent:r,deindent:s,newline:i}=t;n(`_cache[${e.index}] || (`);if(e.isVNode){r();n(`${o(Ro)}(-1),`);i()}n(`_cache[${e.index}] = `);genNode(e.value,t);if(e.isVNode){n(",");i();n(`${o(Ro)}(1),`);i();n(`_cache[${e.index}]`);s()}n(")")}const gr=new RegExp("\\b"+"arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b")+"\\b");const yr=/'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;function validateBrowserExpression(e,t,n=false,o=false){const r=e.content;if(r.trim())try{new Function(o?` ${r} `:"return "+(n?`(${r}) => {}`:`(${r})`))}catch(n){let o=n.message;const s=r.replace(yr,"").match(gr);s&&(o=`avoid using JavaScript keyword as property name: "${s[0]}"`);t.onError(createCompilerError(45,e.loc,void 0,o))}}const transformExpression=(e,t)=>{if(e.type===5)e.content=processExpression(e.content,t);else if(e.type===1)for(let n=0;n<e.props.length;n++){const o=e.props[n];if(o.type===7&&o.name!=="for"){const e=o.exp;const n=o.arg;!e||e.type!==4||o.name==="on"&&n||(o.exp=processExpression(e,t,o.name==="slot"));n&&n.type===4&&!n.isStatic&&(o.arg=processExpression(n,t))}}};function processExpression(e,t,n=false,o=false,r=Object.create(t.identifiers)){validateBrowserExpression(e,t,n,o);return e}const vr=createStructuralDirectiveTransform(/^(if|else|else-if)$/,((e,t,n)=>processIf(e,t,n,((e,t,o)=>{const r=n.parent.children;let s=r.indexOf(e);let i=0;while(s-- >=0){const e=r[s];e&&e.type===9&&(i+=e.branches.length)}return()=>{if(o)e.codegenNode=createCodegenNodeForBranch(t,i,n);else{const o=getParentCondition(e.codegenNode);o.alternate=createCodegenNodeForBranch(t,i+e.branches.length-1,n)}}}))));function processIf(e,t,n,o){if(t.name!=="else"&&(!t.exp||!t.exp.content.trim())){const o=t.exp?t.exp.loc:e.loc;n.onError(createCompilerError(28,t.loc));t.exp=createSimpleExpression("true",false,o)}t.exp&&validateBrowserExpression(t.exp,n);if(t.name==="if"){const r=createIfBranch(e,t);const s={type:9,loc:e.loc,branches:[r]};n.replaceNode(s);if(o)return o(s,r,true)}else{const r=n.parent.children;const s=[];let i=r.indexOf(e);while(i-- >=-1){const a=r[i];if(a&&a.type===3){n.removeNode(a);s.unshift(a)}else{if(!a||a.type!==2||a.content.trim().length){if(a&&a.type===9){t.name==="else-if"&&a.branches[a.branches.length-1].condition===void 0&&n.onError(createCompilerError(30,e.loc));n.removeNode();const r=createIfBranch(e,t);!s.length||n.parent&&n.parent.type===1&&(n.parent.tag==="transition"||n.parent.tag==="Transition")||(r.children=[...s,...r.children]);{const e=r.userKey;e&&a.branches.forEach((({userKey:t})=>{isSameKey(t,e)&&n.onError(createCompilerError(29,r.userKey.loc))}))}a.branches.push(r);const i=o&&o(a,r,false);traverseNode(r,n);i&&i();n.currentNode=null}else n.onError(createCompilerError(30,e.loc));break}n.removeNode(a)}}}}function createIfBranch(e,t){const n=e.tagType===3;return{type:10,loc:e.loc,condition:t.name==="else"?void 0:t.exp,children:n&&!findDir(e,"for")?e.children:[e],userKey:findProp(e,"key"),isTemplateIf:n}}function createCodegenNodeForBranch(e,t,n){return e.condition?createConditionalExpression(e.condition,createChildrenCodegenNode(e,t,n),createCallExpression(n.helper(ao),['"v-if"',"true"])):createChildrenCodegenNode(e,t,n)}function createChildrenCodegenNode(e,t,n){const{helper:o}=n;const r=createObjectProperty("key",createSimpleExpression(`${t}`,false,Do,2));const{children:s}=e;const i=s[0];const a=s.length!==1||i.type!==1;if(a){if(s.length===1&&i.type===11){const e=i.codegenNode;injectProp(e,r,n);return e}{let t=64;let i=g[64];if(!e.isTemplateIf&&s.filter((e=>e.type!==3)).length===1){t|=2048;i+=`, ${g[2048]}`}return createVNodeCall(n,o(Xn),createObjectExpression([r]),s,t+` /* ${i} */`,void 0,void 0,true,false,false,e.loc)}}{const e=i.codegenNode;const t=getMemoedVNodeCall(e);t.type===13&&convertToBlock(t,n);injectProp(t,r,n);return e}}function isSameKey(e,t){if(!e||e.type!==t.type)return false;if(e.type===6){if(e.value.content!==t.value.content)return false}else{const n=e.exp;const o=t.exp;if(n.type!==o.type)return false;if(n.type!==4||n.isStatic!==o.isStatic||n.content!==o.content)return false}return true}function getParentCondition(e){while(true)if(e.type===19){if(e.alternate.type!==19)return e;e=e.alternate}else e.type===20&&(e=e.value)}const br=createStructuralDirectiveTransform("for",((e,t,n)=>{const{helper:o,removeHelper:r}=n;return processFor(e,t,n,(t=>{const s=createCallExpression(o(go),[t.source]);const i=isTemplateNode(e);const a=findDir(e,"memo");const c=findProp(e,"key");const l=c&&(c.type===6?createSimpleExpression(c.value.content,true):c.exp);const u=c?createObjectProperty("key",l):null;const p=t.source.type===4&&t.source.constType>0;const d=p?64:c?128:256;t.codegenNode=createVNodeCall(n,o(Xn),void 0,s,d+` /* ${g[d]} */`,void 0,void 0,true,!p,false,e.loc);return()=>{let c;const{children:d}=t;i&&e.children.some((e=>{if(e.type===1){const t=findProp(e,"key");if(t){n.onError(createCompilerError(33,t.loc));return true}}}));const f=d.length!==1||d[0].type!==1;const m=isSlotOutlet(e)?e:i&&e.children.length===1&&isSlotOutlet(e.children[0])?e.children[0]:null;if(m){c=m.codegenNode;i&&u&&injectProp(c,u,n)}else if(f)c=createVNodeCall(n,o(Xn),u?createObjectExpression([u]):void 0,e.children,`64 /* ${g[64]} */`,void 0,void 0,true,void 0,false);else{c=d[0].codegenNode;i&&u&&injectProp(c,u,n);if(c.isBlock!==!p)if(c.isBlock){r(no);r(getVNodeBlockHelper(n.inSSR,c.isComponent))}else r(getVNodeHelper(n.inSSR,c.isComponent));c.isBlock=!p;if(c.isBlock){o(no);o(getVNodeBlockHelper(n.inSSR,c.isComponent))}else o(getVNodeHelper(n.inSSR,c.isComponent))}if(a){const e=createFunctionExpression(createForLoopParams(t.parseResult,[createSimpleExpression("_cached")]));e.body=createBlockStatement([createCompoundExpression(["const _memo = (",a.exp,")"]),createCompoundExpression(["if (_cached",...l?[" && _cached.key === ",l]:[],` && ${n.helperString(Mo)}(_cached, _memo)) return _cached`]),createCompoundExpression(["const _item = ",c]),createSimpleExpression("_item.memo = _memo"),createSimpleExpression("return _item")]);s.arguments.push(e,createSimpleExpression("_cache"),createSimpleExpression(String(n.cached++)))}else s.arguments.push(createFunctionExpression(createForLoopParams(t.parseResult),c,true))}}))}));function processFor(e,t,n,o){if(!t.exp){n.onError(createCompilerError(31,t.loc));return}const r=t.forParseResult;if(!r){n.onError(createCompilerError(32,t.loc));return}finalizeForParseResult(r,n);const{addIdentifiers:s,removeIdentifiers:i,scopes:a}=n;const{source:c,value:l,key:u,index:p}=r;const d={type:11,loc:t.loc,source:c,valueAlias:l,keyAlias:u,objectIndexAlias:p,parseResult:r,children:isTemplateNode(e)?e.children:[e]};n.replaceNode(d);a.vFor++;const f=o&&o(d);return()=>{a.vFor--;f&&f()}}function finalizeForParseResult(e,t){if(!e.finalized){validateBrowserExpression(e.source,t);e.key&&validateBrowserExpression(e.key,t,true);e.index&&validateBrowserExpression(e.index,t,true);e.value&&validateBrowserExpression(e.value,t,true);e.finalized=true}}function createForLoopParams({value:e,key:t,index:n},o=[]){return createParamsList([e,t,n,...o])}function createParamsList(e){let t=e.length;while(t--)if(e[t])break;return e.slice(0,t+1).map(((e,t)=>e||createSimpleExpression("_".repeat(t+1),false)))}const Cr=createSimpleExpression("undefined",false);const trackSlotScopes=(e,t)=>{if(e.type===1&&(e.tagType===1||e.tagType===3)){const n=findDir(e,"slot");if(n){n.exp;t.scopes.vSlot++;return()=>{t.scopes.vSlot--}}}};const buildClientSlotFn=(e,t,n,o)=>createFunctionExpression(e,n,false,true,n.length?n[0].loc:o);function buildSlots(e,t,n=buildClientSlotFn){t.helper(Oo);const{children:o,loc:r}=e;const s=[];const i=[];let a=t.scopes.vSlot>0||t.scopes.vFor>0;const c=findDir(e,"slot",true);if(c){const{arg:e,exp:t}=c;e&&!isStaticExp(e)&&(a=true);s.push(createObjectProperty(e||createSimpleExpression("default",true),n(t,void 0,o,r)))}let l=false;let u=false;const p=[];const d=new Set;let f=0;for(let e=0;e<o.length;e++){const r=o[e];let m;if(!isTemplateNode(r)||!(m=findDir(r,"slot",true))){r.type!==3&&p.push(r);continue}if(c){t.onError(createCompilerError(37,m.loc));break}l=true;const{children:g,loc:y}=r;const{arg:v=createSimpleExpression("default",true),exp:b,loc:C}=m;let S;isStaticExp(v)?S=v?v.content:"default":a=true;const x=findDir(r,"for");const w=n(b,x,g,y);let E;let k;if(E=findDir(r,"if")){a=true;i.push(createConditionalExpression(E.exp,buildDynamicSlot(v,w,f++),Cr))}else if(k=findDir(r,/^else(-if)?$/,true)){let n=e;let r;while(n--){r=o[n];if(r.type!==3)break}if(r&&isTemplateNode(r)&&findDir(r,"if")){o.splice(e,1);e--;let t=i[i.length-1];while(t.alternate.type===19)t=t.alternate;t.alternate=k.exp?createConditionalExpression(k.exp,buildDynamicSlot(v,w,f++),Cr):buildDynamicSlot(v,w,f++)}else t.onError(createCompilerError(30,k.loc))}else if(x){a=true;const e=x.forParseResult;if(e){finalizeForParseResult(e,t);i.push(createCallExpression(t.helper(go),[e.source,createFunctionExpression(createForLoopParams(e),buildDynamicSlot(v,w),true)]))}else t.onError(createCompilerError(32,x.loc))}else{if(S){if(d.has(S)){t.onError(createCompilerError(38,C));continue}d.add(S);S==="default"&&(u=true)}s.push(createObjectProperty(v,w))}}if(!c){const buildDefaultSlotProperty=(e,t)=>{const o=n(e,void 0,t,r);return createObjectProperty("default",o)};l?p.length&&p.some((e=>isNonWhitespaceContent(e)))&&(u?t.onError(createCompilerError(39,p[0].loc)):s.push(buildDefaultSlotProperty(void 0,p))):s.push(buildDefaultSlotProperty(void 0,o))}const m=a?2:hasForwardedSlots(e.children)?3:1;let g=createObjectExpression(s.concat(createObjectProperty("_",createSimpleExpression(m+` /* ${y[m]} */`,false))),r);i.length&&(g=createCallExpression(t.helper(vo),[g,createArrayExpression(i)]));return{slots:g,hasDynamicSlots:a}}function buildDynamicSlot(e,t,n){const o=[createObjectProperty("name",e),createObjectProperty("fn",t)];n!=null&&o.push(createObjectProperty("key",createSimpleExpression(String(n),true)));return createObjectExpression(o)}function hasForwardedSlots(e){for(let t=0;t<e.length;t++){const n=e[t];switch(n.type){case 1:if(n.tagType===2||hasForwardedSlots(n.children))return true;break;case 9:if(hasForwardedSlots(n.branches))return true;break;case 10:case 11:if(hasForwardedSlots(n.children))return true;break}}return false}function isNonWhitespaceContent(e){return e.type!==2&&e.type!==12||(e.type===2?!!e.content.trim():isNonWhitespaceContent(e.content))}const Sr=new WeakMap;const transformElement=(e,t)=>function postTransformElement(){e=t.currentNode;if(!(e.type===1&&(e.tagType===0||e.tagType===1)))return;const{tag:n,props:o}=e;const r=e.tagType===1;let s=r?resolveComponentType(e,t):`"${n}"`;const i=isObject(s)&&s.callee===po;let a;let c;let l;let u=0;let p;let d;let f;let m=i||s===Qn||s===Zn||!r&&(n==="svg"||n==="foreignObject");if(o.length>0){const n=buildProps(e,t,void 0,r,i);a=n.props;u=n.patchFlag;d=n.dynamicPropNames;const o=n.directives;f=o&&o.length?createArrayExpression(o.map((e=>buildDirectiveArgs(e,t)))):void 0;n.shouldUseBlock&&(m=true)}if(e.children.length>0){if(s===eo){m=true;u|=1024;e.children.length>1&&t.onError(createCompilerError(46,{start:e.children[0].loc.start,end:e.children[e.children.length-1].loc.end,source:""}))}const n=r&&s!==Qn&&s!==eo;if(n){const{slots:n,hasDynamicSlots:o}=buildSlots(e,t);c=n;o&&(u|=1024)}else if(e.children.length===1&&s!==Qn){const n=e.children[0];const o=n.type;const r=o===5||o===8;r&&getConstantType(n,t)===0&&(u|=1);c=r||o===2?n:e.children}else c=e.children}if(u!==0){if(u<0)l=u+` /* ${g[u]} */`;else{const e=Object.keys(g).map(Number).filter((e=>e>0&&u&e)).map((e=>g[e])).join(", ");l=u+` /* ${e} */`}d&&d.length&&(p=stringifyDynamicPropNames(d))}e.codegenNode=createVNodeCall(t,s,a,c,l,p,f,!!m,false,r,e.loc)};function resolveComponentType(e,t,n=false){let{tag:o}=e;const r=isComponentTag(o);const s=findProp(e,"is",false,true);if(s)if(r||false){let e;if(s.type===6)e=s.value&&createSimpleExpression(s.value.content,true);else{e=s.exp;e||(e=createSimpleExpression("is",false,s.loc))}if(e)return createCallExpression(t.helper(po),[e])}else s.type===6&&s.value.content.startsWith("vue:")&&(o=s.value.content.slice(4));const i=isCoreComponent(o)||t.isBuiltInComponent(o);if(i){n||t.helper(i);return i}t.helper(uo);t.components.add(o);return toValidAssetId(o,"component")}function buildProps(e,t,n=e.props,o,r,s=false){const{tag:c,loc:l,children:u}=e;let p=[];const d=[];const f=[];const m=u.length>0;let g=false;let y=0;let v=false;let b=false;let C=false;let S=false;let x=false;let w=false;const E=[];const pushMergeArg=e=>{if(p.length){d.push(createObjectExpression(dedupeProperties(p),l));p=[]}e&&d.push(e)};const analyzePatchFlag=({key:e,value:n})=>{if(isStaticExp(e)){const s=e.content;const a=isOn(s);!a||o&&!r||s.toLowerCase()==="onclick"||s==="onUpdate:modelValue"||i(s)||(S=true);a&&i(s)&&(w=true);a&&n.type===14&&(n=n.arguments[0]);if(n.type===20||(n.type===4||n.type===8)&&getConstantType(n,t)>0)return;s==="ref"?v=true:s==="class"?b=true:s==="style"?C=true:s==="key"||E.includes(s)||E.push(s);!o||s!=="class"&&s!=="style"||E.includes(s)||E.push(s)}else x=true};for(let r=0;r<n.length;r++){const i=n[r];if(i.type===6){const{loc:e,name:n,nameLoc:o,value:r}=i;let s=true;if(n==="ref"){v=true;t.scopes.vFor>0&&p.push(createObjectProperty(createSimpleExpression("ref_for",true),createSimpleExpression("true")))}if(n==="is"&&(isComponentTag(c)||r&&r.content.startsWith("vue:")||false))continue;p.push(createObjectProperty(createSimpleExpression(n,true,o),createSimpleExpression(r?r.content:"",s,r?r.loc:e)))}else{const{name:n,arg:r,exp:u,loc:v,modifiers:b}=i;const C=n==="bind";const S=n==="on";if(n==="slot"){o||t.onError(createCompilerError(40,v));continue}if(n==="once"||n==="memo")continue;if(n==="is"||C&&isStaticArgOf(r,"is")&&(isComponentTag(c)||false))continue;if(S&&s)continue;(C&&isStaticArgOf(r,"key")||S&&m&&isStaticArgOf(r,"vue:before-update"))&&(g=true);C&&isStaticArgOf(r,"ref")&&t.scopes.vFor>0&&p.push(createObjectProperty(createSimpleExpression("ref_for",true),createSimpleExpression("true")));if(!r&&(C||S)){x=true;if(u)if(C){pushMergeArg();d.push(u)}else pushMergeArg({type:14,loc:v,callee:t.helper(ko),arguments:o?[u]:[u,"true"]});else t.onError(createCompilerError(C?34:35,v));continue}C&&b.includes("prop")&&(y|=32);const w=t.directiveTransforms[n];if(w){const{props:n,needRuntime:o}=w(i,e,t);!s&&n.forEach(analyzePatchFlag);S&&r&&!isStaticExp(r)?pushMergeArg(createObjectExpression(n,l)):p.push(...n);if(o){f.push(i);isSymbol(o)&&Sr.set(i,o)}}else if(!a(n)){f.push(i);m&&(g=true)}}}let k;if(d.length){pushMergeArg();k=d.length>1?createCallExpression(t.helper(Co),d,l):d[0]}else p.length&&(k=createObjectExpression(dedupeProperties(p),l));if(x)y|=16;else{b&&!o&&(y|=2);C&&!o&&(y|=4);E.length&&(y|=8);S&&(y|=32)}g||y!==0&&y!==32||!(v||w||f.length>0)||(y|=512);if(!t.inSSR&&k)switch(k.type){case 15:let e=-1;let n=-1;let o=false;for(let t=0;t<k.properties.length;t++){const r=k.properties[t].key;isStaticExp(r)?r.content==="class"?e=t:r.content==="style"&&(n=t):r.isHandlerKey||(o=true)}const r=k.properties[e];const s=k.properties[n];if(o)k=createCallExpression(t.helper(wo),[k]);else{r&&!isStaticExp(r.value)&&(r.value=createCallExpression(t.helper(So),[r.value]));s&&(C||s.value.type===4&&s.value.content.trim()[0]==="["||s.value.type===17)&&(s.value=createCallExpression(t.helper(xo),[s.value]))}break;case 14:break;default:k=createCallExpression(t.helper(wo),[createCallExpression(t.helper(Eo),[k])]);break}return{props:k,directives:f,patchFlag:y,dynamicPropNames:E,shouldUseBlock:g}}function dedupeProperties(e){const t=new Map;const n=[];for(let o=0;o<e.length;o++){const r=e[o];if(r.key.type===8||!r.key.isStatic){n.push(r);continue}const s=r.key.content;const i=t.get(s);if(i)(s==="style"||s==="class"||isOn(s))&&mergeAsArray(i,r);else{t.set(s,r);n.push(r)}}return n}function mergeAsArray(e,t){e.value.type===17?e.value.elements.push(t.value):e.value=createArrayExpression([e.value,t.value],e.loc)}function buildDirectiveArgs(e,t){const n=[];const o=Sr.get(e);if(o)n.push(t.helperString(o));else{t.helper(fo);t.directives.add(e.name);n.push(toValidAssetId(e.name,"directive"))}const{loc:r}=e;e.exp&&n.push(e.exp);if(e.arg){e.exp||n.push("void 0");n.push(e.arg)}if(Object.keys(e.modifiers).length){if(!e.arg){e.exp||n.push("void 0");n.push("void 0")}const t=createSimpleExpression("true",false,r);n.push(createObjectExpression(e.modifiers.map((e=>createObjectProperty(e,t))),r))}return createArrayExpression(n,e.loc)}function stringifyDynamicPropNames(e){let t="[";for(let n=0,o=e.length;n<o;n++){t+=JSON.stringify(e[n]);n<o-1&&(t+=", ")}return t+"]"}function isComponentTag(e){return e==="component"||e==="Component"}const transformSlotOutlet=(e,t)=>{if(isSlotOutlet(e)){const{children:n,loc:o}=e;const{slotName:r,slotProps:s}=processSlotOutlet(e,t);const i=[t.prefixIdentifiers?"_ctx.$slots":"$slots",r,"{}","undefined","true"];let a=2;if(s){i[2]=s;a=3}if(n.length){i[3]=createFunctionExpression([],n,false,false,o);a=4}t.scopeId&&!t.slotted&&(a=5);i.splice(a);e.codegenNode=createCallExpression(t.helper(yo),i,o)}};function processSlotOutlet(e,t){let n='"default"';let o;const r=[];for(let t=0;t<e.props.length;t++){const o=e.props[t];if(o.type===6){if(o.value)if(o.name==="name")n=JSON.stringify(o.value.content);else{o.name=l(o.name);r.push(o)}}else if(o.name==="bind"&&isStaticArgOf(o.arg,"name")){if(o.exp)n=o.exp;else if(o.arg&&o.arg.type===4){const e=l(o.arg.content);n=o.exp=createSimpleExpression(e,false,o.arg.loc)}}else{o.name==="bind"&&o.arg&&isStaticExp(o.arg)&&(o.arg.content=l(o.arg.content));r.push(o)}}if(r.length>0){const{props:n,directives:s}=buildProps(e,t,r,false,false);o=n;s.length&&t.onError(createCompilerError(36,s[0].loc))}return{slotName:n,slotProps:o}}const xr=/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;const transformOn$1=(e,t,n,o)=>{const{loc:r,modifiers:s,arg:i}=e;e.exp||s.length||n.onError(createCompilerError(35,r));let a;if(i.type===4)if(i.isStatic){let e=i.content;e.startsWith("vnode")&&n.onError(createCompilerError(51,i.loc));e.startsWith("vue:")&&(e=`vnode-${e.slice(4)}`);const o=t.tagType!==0||e.startsWith("vnode")||!/[A-Z]/.test(e)?f(l(e)):`on:${e}`;a=createSimpleExpression(o,true,i.loc)}else a=createCompoundExpression([`${n.helperString(No)}(`,i,")"]);else{a=i;a.children.unshift(`${n.helperString(No)}(`);a.children.push(")")}let c=e.exp;c&&!c.content.trim()&&(c=void 0);let u=n.cacheHandlers&&!c&&!n.inVOnce;if(c){const e=Ko(c.content);const t=!(e||xr.test(c.content));const o=c.content.includes(";");validateBrowserExpression(c,n,false,o);(t||u&&e)&&(c=createCompoundExpression([`${t?"$event":"(...args)"} => ${o?"{":"("}`,c,o?"}":")"]))}let p={props:[createObjectProperty(a,c||createSimpleExpression("() => {}",false,r))]};o&&(p=o(p));u&&(p.props[0].value=n.cache(p.props[0].value));p.props.forEach((e=>e.key.isHandlerKey=true));return p};const transformBind=(e,t,n)=>{const{modifiers:o,loc:r}=e;const s=e.arg;let{exp:i}=e;i&&i.type===4&&!i.content.trim()&&(i=void 0);if(!i){if(s.type!==4||!s.isStatic){n.onError(createCompilerError(52,s.loc));return{props:[createObjectProperty(s,createSimpleExpression("",true,r))]}}const t=l(s.content);i=e.exp=createSimpleExpression(t,false,s.loc)}if(s.type!==4){s.children.unshift("(");s.children.push(') || ""')}else s.isStatic||(s.content=`${s.content} || ""`);if(o.includes("camel"))if(s.type===4)s.isStatic?s.content=l(s.content):s.content=`${n.helperString(_o)}(${s.content})`;else{s.children.unshift(`${n.helperString(_o)}(`);s.children.push(")")}if(!n.inSSR){o.includes("prop")&&injectPrefix(s,".");o.includes("attr")&&injectPrefix(s,"^")}return{props:[createObjectProperty(s,i)]}};const injectPrefix=(e,t)=>{if(e.type===4)e.isStatic?e.content=t+e.content:e.content=`\`${t}\${${e.content}}\``;else{e.children.unshift(`'${t}' + (`);e.children.push(")")}};const transformText=(e,t)=>{if(e.type===0||e.type===1||e.type===11||e.type===10)return()=>{const n=e.children;let o;let r=false;for(let e=0;e<n.length;e++){const t=n[e];if(isText$1(t)){r=true;for(let r=e+1;r<n.length;r++){const s=n[r];if(!isText$1(s)){o=void 0;break}o||(o=n[e]=createCompoundExpression([t],t.loc));o.children.push(" + ",s);n.splice(r,1);r--}}}if(r&&(n.length!==1||e.type!==0&&(e.type!==1||e.tagType!==0||e.props.find((e=>e.type===7&&!t.directiveTransforms[e.name]))||false)))for(let e=0;e<n.length;e++){const o=n[e];if(isText$1(o)||o.type===8){const r=[];o.type===2&&o.content===" "||r.push(o);t.ssr||getConstantType(o,t)!==0||r.push(`1 /* ${g[1]} */`);n[e]={type:12,content:o,loc:o.loc,codegenNode:createCallExpression(t.helper(co),r)}}}}};const wr=new WeakSet;const transformOnce=(e,t)=>{if(e.type===1&&findDir(e,"once",true)){if(wr.has(e)||t.inVOnce||t.inSSR)return;wr.add(e);t.inVOnce=true;t.helper(Ro);return()=>{t.inVOnce=false;const e=t.currentNode;e.codegenNode&&(e.codegenNode=t.cache(e.codegenNode,true))}}};const transformModel$1=(e,t,n)=>{const{exp:o,arg:r}=e;if(!o){n.onError(createCompilerError(41,e.loc));return createTransformProps()}const s=o.loc.source;const i=o.type===4?o.content:s;const a=n.bindingMetadata[s];if(a==="props"||a==="props-aliased"){n.onError(createCompilerError(44,o.loc));return createTransformProps()}const c=false;if(!i.trim()||!Ko(i)&&!c){n.onError(createCompilerError(42,o.loc));return createTransformProps()}const u=r||createSimpleExpression("modelValue",true);const p=r?isStaticExp(r)?`onUpdate:${l(r.content)}`:createCompoundExpression(['"onUpdate:" + ',r]):"onUpdate:modelValue";let d;const f=n.isTS?"($event: any)":"$event";d=createCompoundExpression([`${f} => ((`,o,") = $event)"]);const m=[createObjectProperty(u,e.exp),createObjectProperty(p,d)];if(e.modifiers.length&&t.tagType===1){const t=e.modifiers.map((e=>(isSimpleIdentifier(e)?e:JSON.stringify(e))+": true")).join(", ");const n=r?isStaticExp(r)?`${r.content}Modifiers`:createCompoundExpression([r,' + "Modifiers"']):"modelModifiers";m.push(createObjectProperty(n,createSimpleExpression(`{ ${t} }`,false,e.loc,2)))}return createTransformProps(m)};function createTransformProps(e=[]){return{props:e}}const Er=new WeakSet;const transformMemo=(e,t)=>{if(e.type===1){const n=findDir(e,"memo");if(!n||Er.has(e))return;Er.add(e);return()=>{const o=e.codegenNode||t.currentNode.codegenNode;if(o&&o.type===13){e.tagType!==1&&convertToBlock(o,t);e.codegenNode=createCallExpression(t.helper(Vo),[n.exp,createFunctionExpression(void 0,o),"_cache",String(t.cached++)])}}}};function getBaseTransformPreset(e){return[[transformOnce,vr,transformMemo,br,transformExpression,transformSlotOutlet,transformElement,trackSlotScopes,transformText],{on:transformOn$1,bind:transformBind,model:transformModel$1}]}function baseCompile(e,t={}){const o=t.onError||defaultOnError;const r=t.mode==="module";t.prefixIdentifiers===true?o(createCompilerError(47)):r&&o(createCompilerError(48));const s=false;t.cacheHandlers&&o(createCompilerError(49));t.scopeId&&!r&&o(createCompilerError(50));const i=n({},t,{prefixIdentifiers:s});const a=isString(e)?baseParse(e,i):e;const[c,l]=getBaseTransformPreset();transform(a,n({},i,{nodeTransforms:[...c,...t.nodeTransforms||[]],directiveTransforms:n({},l,t.directiveTransforms||{})}));return generate(a,i)}const noopDirectiveTransform=()=>({props:[]});const kr=Symbol("vModelRadio");const _r=Symbol("vModelCheckbox");const Tr=Symbol("vModelText");const Nr=Symbol("vModelSelect");const Rr=Symbol("vModelDynamic");const Ar=Symbol("vOnModifiersGuard");const $r=Symbol("vOnKeysGuard");const Or=Symbol("vShow");const Ir=Symbol("Transition");const Pr=Symbol("TransitionGroup");registerRuntimeHelpers({[kr]:"vModelRadio",[_r]:"vModelCheckbox",[Tr]:"vModelText",[Nr]:"vModelSelect",[Rr]:"vModelDynamic",[Ar]:"withModifiers",[$r]:"withKeys",[Or]:"vShow",[Ir]:"Transition",[Pr]:"TransitionGroup"});let Vr;function decodeHtmlBrowser(e,t=false){Vr||(Vr=document.createElement("div"));if(t){Vr.innerHTML=`<div foo="${e.replace(/"/g,"&quot;")}">`;return Vr.children[0].getAttribute("foo")}Vr.innerHTML=e;return Vr.textContent}const Mr={parseMode:"html",isVoidTag:$,isNativeTag:e=>N(e)||R(e)||A(e),isPreTag:e=>e==="pre",decodeEntities:decodeHtmlBrowser,isBuiltInComponent:e=>e==="Transition"||e==="transition"?Ir:e==="TransitionGroup"||e==="transition-group"?Pr:void 0,getNamespace(e,t,n){let o=t?t.ns:n;if(t&&o===2)if(t.tag==="annotation-xml"){if(e==="svg")return 1;t.props.some((e=>e.type===6&&e.name==="encoding"&&e.value!=null&&(e.value.content==="text/html"||e.value.content==="application/xhtml+xml")))&&(o=0)}else/^m(?:[ions]|text)$/.test(t.tag)&&e!=="mglyph"&&e!=="malignmark"&&(o=0);else t&&o===1&&(t.tag!=="foreignObject"&&t.tag!=="desc"&&t.tag!=="title"||(o=0));if(o===0){if(e==="svg")return 1;if(e==="math")return 2}return o}};const transformStyle=e=>{e.type===1&&e.props.forEach(((t,n)=>{t.type===6&&t.name==="style"&&t.value&&(e.props[n]={type:7,name:"bind",arg:createSimpleExpression("style",true,t.loc),exp:parseInlineCSS(t.value.content,t.loc),modifiers:[],loc:t.loc})}))};const parseInlineCSS=(e,t)=>{const n=parseStringStyle(e);return createSimpleExpression(JSON.stringify(n),false,t,3)};function createDOMCompilerError(e,t){return createCompilerError(e,t,Fr)}const Fr={53:"v-html is missing expression.",54:"v-html will override element children.",55:"v-text is missing expression.",56:"v-text will override element children.",57:"v-model can only be used on <input>, <textarea> and <select> elements.",58:"v-model argument is not supported on plain elements.",59:"v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",60:"Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",61:"v-show is missing expression.",62:"<Transition> expects exactly one child element or component.",63:"Tags with side effect (<script> and <style>) are ignored in client component templates."};const transformVHtml=(e,t,n)=>{const{exp:o,loc:r}=e;o||n.onError(createDOMCompilerError(53,r));if(t.children.length){n.onError(createDOMCompilerError(54,r));t.children.length=0}return{props:[createObjectProperty(createSimpleExpression("innerHTML",true,r),o||createSimpleExpression("",true))]}};const transformVText=(e,t,n)=>{const{exp:o,loc:r}=e;o||n.onError(createDOMCompilerError(55,r));if(t.children.length){n.onError(createDOMCompilerError(56,r));t.children.length=0}return{props:[createObjectProperty(createSimpleExpression("textContent",true),o?getConstantType(o,n)>0?o:createCallExpression(n.helperString(bo),[o],r):createSimpleExpression("",true))]}};const transformModel=(e,t,n)=>{const o=transformModel$1(e,t,n);if(!o.props.length||t.tagType===1)return o;e.arg&&n.onError(createDOMCompilerError(58,e.arg.loc));function checkDuplicatedValue(){const e=findDir(t,"bind");e&&isStaticArgOf(e.arg,"value")&&n.onError(createDOMCompilerError(60,e.loc))}const{tag:r}=t;const s=n.isCustomElement(r);if(r==="input"||r==="textarea"||r==="select"||s){let i=Tr;let a=false;if(r==="input"||s){const o=findProp(t,"type");if(o){if(o.type===7)i=Rr;else if(o.value)switch(o.value.content){case"radio":i=kr;break;case"checkbox":i=_r;break;case"file":a=true;n.onError(createDOMCompilerError(59,e.loc));break;default:checkDuplicatedValue();break}}else hasDynamicKeyVBind(t)?i=Rr:checkDuplicatedValue()}else r==="select"?i=Nr:checkDuplicatedValue();a||(o.needRuntime=n.helper(i))}else n.onError(createDOMCompilerError(57,e.loc));o.props=o.props.filter((e=>!(e.key.type===4&&e.key.content==="modelValue")));return o};const Dr=makeMap("passive,once,capture");const Lr=makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle");const Hr=makeMap("left,right");const jr=makeMap("onkeyup,onkeydown,onkeypress",true);const resolveModifiers=(e,t,n,o)=>{const r=[];const s=[];const i=[];for(let n=0;n<t.length;n++){const o=t[n];if(Dr(o))i.push(o);else if(Hr(o))if(isStaticExp(e))jr(e.content)?r.push(o):s.push(o);else{r.push(o);s.push(o)}else Lr(o)?s.push(o):r.push(o)}return{keyModifiers:r,nonKeyModifiers:s,eventOptionModifiers:i}};const transformClick=(e,t)=>{const n=isStaticExp(e)&&e.content.toLowerCase()==="onclick";return n?createSimpleExpression(t,true):e.type!==4?createCompoundExpression(["(",e,`) === "onClick" ? "${t}" : (`,e,")"]):e};const transformOn=(e,t,n)=>transformOn$1(e,t,n,(t=>{const{modifiers:o}=e;if(!o.length)return t;let{key:r,value:s}=t.props[0];const{keyModifiers:i,nonKeyModifiers:a,eventOptionModifiers:c}=resolveModifiers(r,o,n,e.loc);a.includes("right")&&(r=transformClick(r,"onContextmenu"));a.includes("middle")&&(r=transformClick(r,"onMouseup"));a.length&&(s=createCallExpression(n.helper(Ar),[s,JSON.stringify(a)]));!i.length||isStaticExp(r)&&!jr(r.content)||(s=createCallExpression(n.helper($r),[s,JSON.stringify(i)]));if(c.length){const e=c.map(d).join("");r=isStaticExp(r)?createSimpleExpression(`${r.content}${e}`,true):createCompoundExpression(["(",r,`) + "${e}"`])}return{props:[createObjectProperty(r,s)]}}));const transformShow=(e,t,n)=>{const{exp:o,loc:r}=e;o||n.onError(createDOMCompilerError(61,r));return{props:[],needRuntime:n.helper(Or)}};const transformTransition=(e,t)=>{if(e.type===1&&e.tagType===1){const n=t.isBuiltInComponent(e.tag);if(n===Ir)return()=>{if(!e.children.length)return;hasMultipleChildren(e)&&t.onError(createDOMCompilerError(62,{start:e.children[0].loc.start,end:e.children[e.children.length-1].loc.end,source:""}));const n=e.children[0];if(n.type===1)for(const t of n.props)t.type===7&&t.name==="show"&&e.props.push({type:6,name:"persisted",nameLoc:e.loc,value:void 0,loc:e.loc})}}};function hasMultipleChildren(e){const t=e.children=e.children.filter((e=>e.type!==3&&!(e.type===2&&!e.content.trim())));const n=t[0];return t.length!==1||n.type===11||n.type===9&&n.branches.some(hasMultipleChildren)}const ignoreSideEffectTags=(e,t)=>{if(e.type===1&&e.tagType===0&&(e.tag==="script"||e.tag==="style")){t.onError(createDOMCompilerError(63,e.loc));t.removeNode()}};const Br=[transformStyle,transformTransition];const Ur={cloak:noopDirectiveTransform,html:transformVHtml,text:transformVText,model:transformModel,on:transformOn,show:transformShow};function compile(e,t={}){return baseCompile(e,n({},Mr,t,{nodeTransforms:[ignoreSideEffectTags,...Br,...t.nodeTransforms||[]],directiveTransforms:n({},Ur,t.directiveTransforms||{}),transformHoist:null}))}initDev();const zr=new WeakMap;function getCache(t){let n=zr.get(t!=null?t:e);if(!n){n=Object.create(null);zr.set(t!=null?t:e,n)}return n}function compileToFunction(e,t){if(!isString(e)){if(!e.nodeType){Yt("invalid template option: ",e);return NOOP}e=e.innerHTML}const o=e;const r=getCache(t);const s=r[o];if(s)return s;if(e[0]==="#"){const t=document.querySelector(e);t||Yt(`Template element not found or is empty: ${e}`);e=t?t.innerHTML:""}const i=n({hoistStatic:true,onError:onError,onWarn:e=>onError(e,true)},t);i.isCustomElement||typeof customElements==="undefined"||(i.isCustomElement=e=>!!customElements.get(e));const{code:a}=compile(e,i);function onError(t,n=false){const o=n?t.message:`Template compilation error: ${t.message}`;const r=t.loc&&generateCodeFrame(e,t.loc.start.offset,t.loc.end.offset);Yt(r?`${o}\n${r}`:o)}const c=new Function("Vue",a)(Yn);c._rc=true;return r[o]=c}registerRuntimeCompiler(compileToFunction);export{nt as BaseTransition,et as BaseTransitionPropsValidators,$t as Comment,on as DeprecationTypes,EffectScope,ge as ErrorCodes,Xt as ErrorTypeStrings,Rt as Fragment,rt as KeepAlive,ReactiveEffect,Ot as Static,Ke as Suspense,Nt as Teleport,At as Text,fe as TrackOpTypes,Transition,Mn as TransitionGroup,he as TriggerOpTypes,VueElement,assertNumber,callWithAsyncErrorHandling,callWithErrorHandling,l as camelize,d as capitalize,cloneVNode,nn as compatUtils,compileToFunction as compile,computed,createApp,createBlock,createCommentVNode,createElementBlock,createBaseVNode as createElementVNode,createHydrationRenderer,createPropsRestProxy,createRenderer,createSSRApp,createSlots,createStaticVNode,createTextVNode,Ft as createVNode,customRef,defineAsyncComponent,defineComponent,defineCustomElement,defineEmits,defineExpose,defineModel,defineOptions,defineProps,defineSSRCustomElement,defineSlots,Qt as devtools,effect,effectScope,getCurrentInstance,getCurrentScope,getTransitionRawChildren,guardReactiveProps,h,handleError,hasInjectionContext,hydrate,initCustomFormatter,Jn as initDirectivesForSSR,inject,isMemoSame,isProxy,isReactive,isReadonly,isRef,isRuntimeOnly,isShallow,isVNode,markRaw,mergeDefaults,mergeModels,mergeProps,nextTick,normalizeClass,normalizeProps,normalizeStyle,onActivated,st as onBeforeMount,lt as onBeforeUnmount,at as onBeforeUpdate,onDeactivated,onErrorCaptured,it as onMounted,ft as onRenderTracked,dt as onRenderTriggered,onScopeDispose,pt as onServerPrefetch,ut as onUnmounted,ct as onUpdated,openBlock,popScopeId,provide,proxyRefs,pushScopeId,queuePostFlushCb,reactive,readonly,ref,registerRuntimeCompiler,render,renderList,renderSlot,resolveComponent,resolveDirective,resolveDynamicComponent,tn as resolveFilter,resolveTransitionHooks,setBlockTracking,Zt as setDevtoolsHook,setTransitionHooks,shallowReactive,shallowReadonly,shallowRef,Je as ssrContextKey,en as ssrUtils,stop,toDisplayString,f as toHandlerKey,toHandlers,toRaw,toRef,toRefs,toValue,transformVNodeArgs,triggerRef,unref,useAttrs,useCssModule,useCssVars,useModel,useSSRContext,useSlots,useTransitionState,Ln as vModelCheckbox,Bn as vModelDynamic,Hn as vModelRadio,jn as vModelSelect,Dn as vModelText,vn as vShow,Jt as version,Yt as warn,watch,watchEffect,watchPostEffect,watchSyncEffect,withAsyncContext,withCtx,withDefaults,withDirectives,withKeys,withMemo,withModifiers,withScopeId};

